---
title: "Introduction au Tidyverse"
subtitle: "Utiliser le Tidyverse pour manipuler des données"
author:
  - Sandra Angers-Blondin
  - Jonathan Kitt (adaptation)
date: "2022-10-24"
draft: false
categories: [R, RStudio, Tidyverse]
format: 
  html: 
    toc: true
    toc-depth: 2
    toc-title: "Sommaire"
---

```{r, include=FALSE}
library(tidyverse)
```

*Ce tutoriel est adapté de [Basic data manipulation](https://ourcodingclub.github.io/tutorials/data-manip-intro/index.html) et [Efficient data manipulation](https://ourcodingclub.github.io/tutorials/data-manip-efficient/) du site [Our Coding Club](https://ourcodingclub.github.io/).*

<br>

# Introduction

## Qu'est-ce que le Tidyverse ?

Le [Tidyverse](https://www.tidyverse.org/) est un ensemble de packages proposant de multiples fonctions utiles à l'ensemble des étapes d'une analyse :

|                                               |                                       |
|:--------------------------------------|:--------------------------------|
| [readr](https://readr.tidyverse.org/)         | importer et exporter les données      |
| [tibble](https://tibble.tidyverse.org/)       | format de tableau propre au tidyverse |
| [dplyr](https://dplyr.tidyverse.org/)         | manipuler les données                 |
| [tidyr](https://tidyr.tidyverse.org/)         | transformer des tableaux              |
| [stringr](https://stringr.tidyverse.org/)     | manipuler des chaînes de caractères   |
| [forcats](https://forcats.tidyverse.org/)     | manipuler des variables catégorielles |
| [ggplot2](https://ggplot2.tidyverse.org/)     | représenter les données               |
| [purrr](https://purrr.tidyverse.org/)         | programmation fonctionnelle           |
| [lubridate](https://lubridate.tidyverse.org/) | manipuler des dates                   |

<br>

## Pré-requis

Si vous n'avez pas suivi les autres tutoriels, vous pouvez [créer un projet RStudio](https://ateliers-codons.netlify.app/posts/02-premiers-pas-avec-r/#créer-un-projet) et [une arborescence](https://ateliers-codons.netlify.app/posts/02-premiers-pas-avec-r/#créer-une-arborescence).

Pour utiliser le Tidyverse, vous pouvez soit installer et charger séparément les packages dont vous aurez besoin, soit installer et charger directement la suite complète :

```{r, echo=TRUE, eval=FALSE}
# Installer et charger les packages readr et dplyr
install.packages(c("readr", "dplyr"))
library(readr)
library(dplyr)

# Installer et charger la suite Tidyverse
install.packages("tidyverse")
library(tidyverse)
```

::: {.callout-caution icon="true"}
## Les conflits

Lorsque vous exécutez la fonction `library(tidyverse)`, le message suivant s'affiche dans la console :

![](img/tidyverse_intro_01.png)

R vous indique :

-   le nom et la version des packages individuels (*Attaching packages*)\
-   les fonctions portant des noms identiques existant dans d'autres packages (*Conflicts*)

Il existe par exemple une fonction `filter()` dans le package `stats`. Si vous souhaitez utiliser cette dernière fonction plutôt que celle proposée dans le package `dplyr`, il vous foudra préciser le package en question : `stats::filter()`.
:::

<br>

# Premiers pas dans le Tidyverse

Les fonctions proposées dans les différents packages de la suite Tidyverse sont - en règle générale - nommées d'après les actions qu'elles accomplissent, ce qui rend leur mémorisation plus simple et leur utilisation plus intuitive.

## Importer les données

Nous allons utiliser le même jeu de données que dans les tutoriels précédents (vous pouvez le télécharger [ici](https://raw.githubusercontent.com/codons-blog/ateliers-codons.netlify/main/raw/pingouins.csv) et le sauvegarder dans votre dossier `raw/`).

Pour importer les données, nous utilisons la fonction `read_csv()`, à ne pas comprendre avec la fonction `read.csv()` utilisée précédemment.

```{r importer les donnees 1, echo=FALSE, eval=TRUE, message=FALSE, warning=FALSE}
pingouins <- read_csv(file = "../../raw/pingouins.csv")
```

```{r importer les donnees 2, echo=TRUE, eval=FALSE}
pingouins <- readr::read_csv(file = "raw/pingouins.csv")
```

Vous pouvez voir dans la console des informations concernant vos données :\
- les *dimensions* du tableau\
- le *séparateur* de colonnes\
- les *types* et les *noms* des variables

<br>

Tapez `pingouins` dans la console et appuyze sur `Entrée` : vos données s'affichent et vous pouvez voir qu'il s'agit d'un *tibble*, qui présente quelques particularités par rapport à un tableau "classique" :

-   les dimensions du *tibble* sont précisées\
-   les *types* des variables sont indiquées sous les noms des colonnes\
-   seules les *dix premières lignes* sont affichées\
-   le nombre de colonnes affichées dépend de la largeur de l'écran\
-   les noms de colonnes sont raccourcis si nécessaire\
-   les données manquantes *NA* sont mises en évidence

Pour bien voir la différence entre un `tibble` et un `data.frame`, comparez les deux commandes suivantes :

```{r tibble vs dataframe, echo=TRUE, eval=FALSE}
pingouins
as.data.frame(pingouins)
```

<br>

## Explorer les données

Plusieurs fonctions incluses dans R permettent d'explorer rapidement des données pour s'assurer qu'elles ont été correctement importées :

```{r explorer, echo=TRUE, eval=FALSE}
# Afficher les premieres lignes
head(pingouins)

# Afficher les dernieres lignes
tail(pingouins)

# Afficher la structure des donnees
str(pingouins)
```

La fonction `glimpse()` (du package `readr`) retourne sensiblement les mêmes informations que la fonction `str()` :

```{r glimpse, echo=TRUE, eval=FALSE}
dplyr::glimpse(pingouins)
```

<br>

## Créer une copie de travail

La première chose à faire avant de manipuler, modifier et transformer nos données est de créer une copie de travail : cela nous permettra, en cas d'erreur, de repartir des données d'origines.

```{r copie de travail}
pingouins_tmp <- pingouins
```

<br>

## Renommer des colonnes

Commençons par renommer des colonnes afin de respecter les conventions d'écriture :

-   *snake_case* : caractères minuscules, mots séparés par des `_`\
-   *camelCase* : aucune séparation entre les mots, majuscule pour débuter un mot

La fonction `rename` s'utilise de la façon suivante : `rename(data, nouveau nom = ancien nom)`

```{r rename 1, echo=TRUE, eval=FALSE}
dplyr::rename(pingouins_tmp, ile = Ile)
```

Nous pourrions procéder de la même façon pour plusieurs colonnes à la fois :

```{r rename 2, echo=TRUE, eval=FALSE}
dplyr::rename(pingouins_tmp, espece = Espece, ile = Ile)
```

<br>

Le package [`janitor`](https://cran.r-project.org/web/packages/janitor/vignettes/janitor.html) est dédié au nettoyage d'un tableau (noms de colonnes, suppression des doublons, ...). Utilisons la fonction `clean_names()` de ce package :

```{r clean names, echo=TRUE, eval=FALSE}
janitor::clean_names(pingouins_tmp)
```

Assignons ces noms de colonnes nettoyés à notre copie de travail :

```{r assign clean names}
pingouins_tmp <- janitor::clean_names(pingouins_tmp)
```

Assurons-nous que les noms de colonnes ont bien été modifiés :

```{r verif noms, eval=FALSE}
names(pingouins_tmp)
```

<br>

::: {.callout-tip icon="true"}
## Explorer les arguments d'une fonction

Pour afficher l'aide de la fonction `clean_names`, tapez `?clean_names` (ou `?janitor::clean_names`) dans la console. Vous trouverez dans l'aide toutes les informations concernant une fonction. Dans notre cas, nous pourrions utiliser différentes conventions d'écriture pour nos noms de colonnes : `clean_names(pingouins_tmp, case = "lower_camel")` par exemple.
:::

<br>

## Sélectionner des colonnes

La fonction `select()` permet de sélectionner les colonnes d'un tableau. Nous allons sélectionner les colonnes *espece*, *ile*, *longueur_bec_mm*, *hauteur_bec_mm*, *longueur_aile_mm* et *masse_corporelle_g*. Nous pouvons procéder de plusieurs façons :

```{r select columns, eval=FALSE}
# Indiquer toutes les colonnes
dplyr::select(pingouins_tmp, espece, ile, longueur_bec_mm, hauteur_bec_mm,
              longueur_aile_mm, masse_corporelle_g)

# Indiquer les suites de colonnes
dplyr::select(pingouins_tmp, espece:ile, longueur_bec_mm:masse_corporelle_g)

# Supprimer des colonnes
dplyr::select(pingouins_tmp, espece:ile, longueur_bec_mm:masse_corporelle_g)
```

D'autres fonctions du package `dplyr` permettent de sélectionner des colonnes :

-   `contains()` : sélectionner les noms de colonnes qui contiennent un motif\
-   `starts_width()` : sélectionner les noms de colonnes qui commencent par un motif\
-   `ends_width()` : sélectionner les noms de colonnes qui se terminent par un motif

Dans notre cas, nous pouvons sélectionner les colonnes *espece* et *ile*, puis les colonnes dont le nom se termine par *mm* ou par *g* :

```{r select columns 2, eval=FALSE}
# Utiliser la fonction ends_with()
dplyr::select(pingouins_tmp, espece, ile, dplyr::ends_with(c("mm", "g")))
```

Assignons cette sélection de colonnes à notre objet :

```{r assign selection}
pingouins_tmp <- dplyr::select(pingouins_tmp, espece, ile, dplyr::ends_with(c("mm", "g")))
```

<br>

::: {.callout-tip icon="true"}
## Renommer et ré-ordonner des colonnes avec `select()`

Nous pouvons utiliser la fonction `select()` pour renommer des colonnes :

```{r rename with select, eval=FALSE}
dplyr::select(pingouins_tmp, espece:longueur_aile_mm, masse = masse_corporelle_g)
```

Mais aussi pour modifier l'ordre des colonnes :

```{r reorder with select, eval=FALSE}
dplyr::select(pingouins_tmp, espece:ile, masse_corporelle_g, longueur_bec_mm:longueur_aile_mm)
```

Enfin, si nous n'avons que quelques colonnes à déplacer, la fonction `everything()` permet de sélectionner le reste du tableau !

```{r everything, eval=FALSE}
dplyr::select(pingouins_tmp, ile, dplyr::everything())
```
:::

<br>

## Filtrer des données

La fonction `filter()` permet de filtrer les données à l'aide d'opérateurs logiques :

|        |                     |
|--------|---------------------|
| `==`   | strictement égal à  |
| `<=`   | inférieur ou égal à |
| `<`    | inférieur à         |
| `>=`   | supérieur ou égal à |
| `>`    | supérieur à         |
| `!=`   | différent de        |
| `%in%` | appartient à        |
| `&`    | et                  |
| `|`    | ou                  |
| `!`    | négation            |

Voici deux exemples :

```{r filtrer, eval=FALSE}
# Individus vivant sur l'ile Biscoe pesant au moins 5 kgs
dplyr::filter(pingouins_tmp, ile == "Biscoe", masse_corporelle_g >= 5000)

# Individus vivant sur les iles Biscoe ou Torgersen
dplyr::filter(pingouins_tmp, ile %in% c("Biscoe", "Torgersen"))
```

La fonction `between()` permet de garder les valeurs numériques entre deux bornes :

```{r between, eval=FALSE}
# Individus pesant entre 3 kgs et 3,5 kgs
dplyr::filter(pingouins_tmp, dplyr::between(masse_corporelle_g, 3000, 3250))
```

<br>

Notre jeu de données contient des données manquantes `NA`. Il existe plusieurs manières de supprimer ces données manquantes :

```{r remove NAs, eval=FALSE}
# Garder les lignes pour lesquelles la variable longueur_bec_mm ne contient pas de NA
dplyr::filter(pingouins_tmp, !is.na(longueur_bec_mm))

# Supprimer les lignes pour lesquelles la variable longueur_bec_mm contient au moins un NA
tidyr::drop_na(pingouins_tmp, longueur_bec_mm)

# Supprimer les lignes contenant des NAs, quelque soit la variable
tidyr::drop_na(pingouins_tmp)
```

<br>

## Trier des données

La fonction `arrange()` permet de trier des données. Par défaut, le tri s'effectue par ordre croissant. Pour trier des données par ordre décroissant, il faut ajouter la fonction `desc()`.

```{r tri, eval=FALSE}
# Trier les données par ordre croisant de longueur de bec
dplyr::arrange(pingouins_tmp, longueur_bec_mm)

# Trier les données par ordre décroissant de masse corporelle
dplyr::arrange(pingouins_tmp, dplyr::desc(masse_corporelle_g))
```

Il est possible de trier sur plusieurs colonnes : nous pouvons trier les individus par ordre décroissant de hauteur de bec puis par ordre décroissant de longueur de bec. Cela peut être utile pour départager des individus "ex-aequo" pour une variable :

```{r tri 2, eval=FALSE}
dplyr::arrange(pingouins_tmp, dplyr::desc(hauteur_bec_mm), dplyr::desc(longueur_bec_mm))
```

## Créer ou modifier des colonnes

La fonction `mutate()` permet de créer une nouvelle colonne. Nous pouvons par exemple ajouter une colonne *ratio_bec* dans laquelle nous allons calculer le rapport entre la longueur du bec et sa hauteur :

```{r mutate, eval=FALSE}
dplyr::mutate(pingouins_tmp, ratio_bec = longueur_bec_mm / hauteur_bec_mm)
```

Nous pouvons également modifier le contenu d'une colonne, par exemple en ajoutant le suffixe *island* au contenu de la colonne *ile* :

```{r mutate 2, eval=FALSE}
dplyr::mutate(pingouins_tmp, ile = paste0(ile, " island"))
```

La fonction `transmute()` permet quant à elle de créer une nouvelle colonne tout en supprimant les colonnes pré-existantes :

```{r transmute, eval=FALSE}
dplyr::transmute(pingouins_tmp, masse_kgs = masse_corporelle_g / 1000)
```

<br>

## Effectuer des comptages

La fonction `count()` permet d'effectuer des comptages sur les variables.

Comptons le nombre d'individus par espèce :

```{r count, eval=FALSE}
dplyr::count(pingouins_tmp, espece)
```

L'argument `sort = TRUE` permet d'afficher le résultat par ordre décroissant :

```{r count 2, eval=FALSE}
dplyr::count(pingouins_tmp, espece, sort = TRUE)
```

Nous pouvons également compter les individus par île et par espèce :

```{r count 3, eval=FALSE}
dplyr::count(pingouins_tmp, ile, espece, sort = TRUE)
```

<br>

## Agréger des lignes

La fonction `summarise()` permet d'agréger des lignes en effectuant une opération.

Calculons la longueur moyenne du bec pour l'ensemble des individus, sans oublier l'argument `na.rm = TRUE` pour supprimer les données manquantes lors du calcul. Si nous avions assigné à l'objet `pingouins_tmp` les données après avoir retiré les lignes contenant des données manquantes, nous pourrions nous passer de cet argument. Dans le doute, mieux vaut ajouter cet argument :

```{r summarise, eval=FALSE}
dplyr::summarise(pingouins_tmp,
                 longueur_bec_mm_moy = mean(longueur_bec_mm, na.rm = TRUE))
```

Cette fonction peut également s'utiliser sur plusieurs variables :

```{r summarise 2, eval=FALSE}
dplyr::summarise(pingouins_tmp,
                 longueur_bec_mm_moy = mean(longueur_bec_mm, na.rm = TRUE),
                 hauteur_bec_mm_moy = mean(hauteur_bec_mm, na.rm = TRUE))
```

<br>

## Regrouper les données

La fonction `group_by()`, utilisée en combinaison avec la fonction `summarise()`, permet de regrouper les données pour effectuer des calculs par groupe.

Calculons la longueur moyenne du bec par espece :

```{r group, eval=FALSE}
dplyr::summarise(group_by(pingouins_tmp, espece),
                 longueur_bec_mm_moy = mean(longueur_bec_mm, na.rm = TRUE))
```

Cette fonction permet de définir des sous-groupes. Calculons la longueur moyenne du bec par île et par espèce :

```{r group 2, eval=FALSE}
dplyr::summarise(dplyr::group_by(pingouins_tmp, ile, espece),
                 longueur_bec_mm_moy = mean(longueur_bec_mm, na.rm = TRUE))
```

<br>

# "Ceci n'est pas un pipe"

Jusqu'à présent, nous avons utilisé les fonctions une par une, en créant si nécessaire des objets intermédiaires. Cette façon de procéder peut rapidement encombrer notre environnement.

Il existe une façon d'enchaîner les fonctions les unes à la suite des autres, qui présente plusieurs avantages :

-   rendre le code plus clair et lisible\
-   réduire le nombre d'objets intermédiaires nécessaires à l'analyse\
-   permettre d'utiliser l'auto-complétion (à l'aide de la touche `Tab`)

L'enchaînement des fonctions s'effectue à l'aide de ce que l'on appelle un *pipe*, disponible dans le package [`magrittr`](https://magrittr.tidyverse.org/).

![](img/pipe_logo.png){width="20%"}

Un pipe s'écrit `%>%` et se place à la fin d'une ligne : 

```{r pipe, eval=FALSE}
pingouins %>%
  janitor::clean_names()
```


::: {.callout-tip icon="true"}
## Raccourci clavier : le pipe

Pour insérer un pipe, utilisez la combinaison *Ctrl + Shift + M*

:::

<br>

Nous pouvons ainsi enchaîner les fonctions sans avoir à créer des objets intermédiaires : 

```{r pipe 2, eval=FALSE}
pingouins %>%
  janitor::clean_names() %>%
  dplyr::drop_na()
```

<br>

::: {.callout-important icon="false" collapse="true"}
## Exercice 1 - énoncé

Reprenons depuis le début et utilisons le pipe pour enchaîner les fonctions. 
Les commentaires ci-dessous indiquent les étapes : 

```{r ex1, eval=FALSE}
# Assigner les étapes suivantes dans un objet pingouins_tmp
# Importer les donnees brutes
# Nettoyer les noms de colonnes
# Selectionner les colonnes espece, ile ainsi que les variables numeriques
# Supprimer les lignes contenant des donnees manquantes
# Ajouter une colonne ratio_bec contenant le rapport entre la longueur et la hauteur des becs
```

:::

::: {.callout-important icon="false" collapse="true"}
## Exercice 1 - solution

```{r ex1 sol, eval=FALSE}
pingouins_tmp <- readr::read_csv("raw/pingouins.csv") %>%
  janitor::clean_names() %>%
  dplyr::select(espece, ile, ends_with(c("mm", "g"))) %>%
  tidyr::drop_na() %>%
  dplyr::mutate(ratio_bec = longueur_bec_mm / hauteur_bec_mm)
```

:::

<br>

::: {.callout-note icon="true"}
## Le pipe "natif" `|>`

Les versions les plus récentes de R (à partir de 4.1) proposent un pipe "natif", qui ne nécessite pas de faire appel au package `magrittr`. Ce pipe s'écrit sous la forme `|>`. 

Pour utiliser le pipe `|>`, cliquez sur *Tools* > *Global Options*. Dans le menu *Code* et l'onglet *Editing*,cochez la case *Use native pipe operator*.

![](img/tidyverse_intro_02.png){width="50%}

Le raccourci clavier **Ctrl + Shift + M** insérera alors un pipe `|>`.

:::

<br>

# Manipuler des chaînes de caractères avec `stringr`

Le package `stringr` est dédié à la manipulation de chaînes de caractères. Nous aimerions séparer la colonne *espece* en deux colonnes : 

- une colonne contenant le nom de l'espèce (*Adelie* par exemple)  
- une colonne contenant le nom latin de l'espèce (*Pygoscelis adeliae*)

La fonction `str_detect()` permet de rechercher un motif dans une chaîne de caractères : 

```{r stringr 1, eval=FALSE}
stringr::str_detect(string = pingouins_tmp$espece, pattern = "Adelie")
```

Utilisons la fonction `word()` pour extraire les troisèmes et quatrièmes mots de la variable espèce. Cette fonction s'utilise de la manière suivante : `str_word(chaine, debut, fin)`.

```{r stringr 2, eval=FALSE}
pingouins_tmp <- pingouins_tmp %>%
  dplyr::mutate(nom_latin = stringr::word(string = espece,
                                          start = 3, end = 4))
```

Notre nouvelle variable *nom_latin* a bien été créée, mais elle contient des parenthèses. Pour les supprimer, nous utilisons la fonction `str_remove_all()` en combinaison avec une expression régulière (regex) : les parenthèses à supprimer sont placées entre crochets, eux-mêmes placés entre des guillemets.

```{r stringr 3, eval=FALSE}
pingouins_tmp <- pingouins_tmp %>%
  dplyr::mutate(nom_latin = stringr::str_remove_all(string = nom_latin,
                                                    pattern = "[()]"))
```

Il ne nous reste plus qu'à modifier la variable *espece* afin de ne conserver que le premier mot, puis de modifier l'ordre des colonnes :

```{r stringr 4, eval=FALSE}
pingouins_tmp <- pingouins_tmp %>%
  dplyr::mutate(espece = stringr::word(string = espece,
                                       start = 1, end = 1)) %>%
  dplyr::select(espece, nom_latin, dplyr::everything())
```

<br>

::: {.callout-tip icon="true"}
## Les expressions régulières

Pour en savoir plus sur les expressions régulières, vous pouvez lire [cet article](https://thinkr.fr/r-les-expressions-regulieres/).
Il existe souvent plusieurs façons d'arriver au même résultat. Pour le nom latin, nous aurions pu extraire la chaîne de caractères située entre les parenthèses : 

```{r stringr 5, eval=FALSE}
stringr::str_extract(pingouins$Espece, "(?<=\\().+?(?=\\))")
```

Pour extraire le nom de l'espèce, nous pouvons utiliser une expression régulière pour extraire les caractères précédent le premier espace vide : 

```{r stringr 6, eval=FALSE}
stringr::str_extract(pingouins$Espece, "\\w+")
```

:::

<br>

# Joindre des tableaux

Le package `dplyr` propose plusieurs fonctions pour joindre deux tableaux. Les lignes des deux tableaux seront associées en fonction de *clés*, c'est-à-dire des colonnes communes.

Le schéma ci-dessous (tiré du livre [R for Data Science](https://r4ds.had.co.nz/relational-data.html)) représente les différentes fonctions `..._join()` : 

![](img/join-venn.png){width="50%"}

<br>

Pour bien comprendre ces différentes fonctions, nous allons créer deux sous-ensembles de données : 

- `d1` : lignes 1 à 3 du tableau, variable *longueur_bec_mm*  
- `d2` : lignes 2 à 4 du tableau, variable *hauteur_bec_mm*

Nous commençons par ajouter une colonne contenant les numéros de ligne, à l'aide de la fonction `rowid_to_column()` du package `tibble`. Par défaut, cette fonction la colonne d'index au début du tableau, et l'argument `var = ` permet de choisir le nom de cette colonne. La fonction `slice()` permet de créer un sous-ensemble de lignes à l'aide de leurs positions.

```{r, join 1, eval=TRUE}
d1 <- pingouins_tmp %>%
  tibble::rowid_to_column(var = "ind_num") %>%
  dplyr::select(ind_num, longueur_bec_mm) %>%
  dplyr::slice(1:3)

d2 <- pingouins_tmp %>%
  tibble::rowid_to_column(var = "ind_num") %>%
  dplyr::select(ind_num, hauteur_bec_mm) %>%
  dplyr::slice(2:4)
```

|                      |                                      | 
| -------------------- | ------------------------------------ |
| `inner_join(d1, d2)` | ![](img/inner_join.png){width="50%"} |
| `full_join(d1, d2)`  | ![](img/full_join.png){width="50%"}  |
| `left_join(d1, d2)`  | ![](img/left_join.png){width="50%"}  |
| `right_join(d1, d2)` | ![](img/right_join.png){width="50%"} |
| `anti_join(d1, d2)`  | ![](img/anti_join_1.png){width="50%"}|
| `anti_join(d2, d1)`  | ![](img/anti_join_2.png){width="50%"}|


Le fichier `traitements.csv` contient des informations sur des **traitements appliqués aux plantes** : températe (T), fertilisation (F), température + fertilisation (TF), ou contrôle (C).

```{r, echo=TRUE, eval=FALSE}
# Importer le jeu de données (attention : utilisation de read_csv2)

traitements <- read_csv2("https://raw.githubusercontent.com/codons-blog/C-02-ManipulationDonnees/main/traitements.csv")
```

<br>

Nous allons utiliser la fonction `left_join()` pour garder toutes les données présentes dans `croissance` et y associer les données présentes dans `traitements` :

```{r, echo=TRUE, eval=FALSE}
# Joindre deux jeux de données

expe <- croissance %>% 
  left_join(traitements,
            by = c("zone" = "Zone",
                   "indiv" = "Indiv"))
```

<br>

Si les noms des deux premières colonnes avaient été strictement identiques dans les deux tableaux, nous aurions pu nous passer de l'argument `by()`.

<br>

# Mettre en forme des données à l'aide de `tidyr` {#tidyr}

Les données que nous avons manipulées jusqu'à présent ne sont **pas dans un format idéal** (rappelez-vous la longueur du code pour calculer la croissance totale pour chaque individu).

Les valeurs mesurées sont réparties dans différentes colonnes, une par année.

Nous pourrions mettre en forme ces donnes afin d'avoir une colonne "annee" et une colonne "croissance".

C'est ce qu'on appelle des **tidy data**, concept qui repose sur trois critères :

**1. Chaque variable est située dans sa propre colonne**\
**2. Chaque observation est située sur sa propre ligne**\
**3. Chaque valeur est située dans sa propre cellule**

# `{r, layout="l-body"} # knitr::include_graphics("img/tidy-1.png") #`

# Figure tirée de [R for Data Science](https://r4ds.had.co.nz/tidy-data.html)

<br>

Considérons les deux premières lignes de notre tableau `croissance`, voici à quoi ressemblerait un format **tidy** :

# `{r, layout="l-body-outset"} # knitr::include_graphics("img/tidy_data.png") #`

<br>

Ce format **facilite les analyses** en permettant des comparaisons entre groupes, traitements, espèces, années, ...

Le package `tidyr` permet de jongler entre ces deux formats grâce aux fonctions `pivot_...()`.

# `{r, layout="l-body"} # knitr::include_graphics("img/giphy.gif") #`

<br>

## Format long avec `pivot_longer()`

La fonction `pivot_longer()` permet de passer d'un format large à un format long. La syntaxe est un peu plus complexe que les fonctions que nous avons vues jusqu'à présent, car il nous préciser quelles colonnes vont être regroupées :

# `{r, layout="l-body-outset"} # knitr::include_graphics("img/pivot_longer.png") #`

```{r, echo=TRUE, eval=FALSE}
# Format large -> format long

croissance_long <- croissance %>% 
  pivot_longer(cols = `2007`:`2012`,
               names_to = "annee",
               values_to = "croissance")
```

<br>

## Format large avec `pivot_wider()`

Cette fonction permet d'effectuer l'opération inverse :

# `{r, layout="l-body-outset"} # knitr::include_graphics("img/pivot_wider.png") #`

```{r, echo=TRUE, eval=FALSE}
# Format long -> format large

croissance_large <- croissance_long %>% 
  pivot_wider(id_cols = zone:indiv,
              names_from = annee,
              values_from = croissance)
```

<br>

Dans les arguments `names_from` et `values_from` nous n'utilisons pas de guillemets car ces colonnes existent, contraitement aux arguments `names_to` et `values_to` de la fonction `pivot_longer()` qui permettent de créer des colonnes inexistantes.

<br>

## Résumé

Nous avons vu les principales fonctions des packages `dplyr` et `tidyr` une par une. Nous allons maintenant **enchaîner les différentes opérations** depuis le début à l'aide d'un `pipe` et **visualiser l'effet des différents traitements** sur la croissance des tiges d'*Empetrum* :

```{r, echo=TRUE, eval=FALSE}

# Importer les deux fichiers

croissance <- read_csv("https://raw.githubusercontent.com/codons-blog/C-02-ManipulationDonnees/main/croissance.csv")
traitements <- read_csv2("https://raw.githubusercontent.com/codons-blog/C-02-ManipulationDonnees/main/traitements.csv")

# Mettre en forme et joindre les deux fichiers

expe <- croissance %>% 
  pivot_longer(cols = `2007`:`2012`,
               names_to = "annee",
               values_to = "croissance") %>% 
  left_join(traitements) %>% 
  rename(zone = Zone,
         indiv = Indiv,
         traitement = Traitement) %>% 
  mutate(zone = as.factor(zone),
         indiv = as.factor(indiv),
         annee = as.numeric(annee),
         traitement = as.factor(traitement))

# Boxplot de l'effet des traitements sur la croissance

boxplot(croissance ~ traitement, 
        data = expe,
        main = "Effet de la température (T) et de la fertilisation (F) sur la croissance d'Empetrum",
        xlab = "Traitement",
        ylab = "Croissance des tiges (cm)")
```

<br>

# `{r, layout="l-body-outset"} # knitr::include_graphics("img/boxplot.png") #`

<br>

## Bilan du tutoriel :

1.  Vous savez utiliser les fonctions de `dplyr` pour manipuler vos données\
2.  Vous savez mettre en forme des données qui respectent les critères des tidy data avec `tidyr`

<br>

# Défi {#defi}

Pour ce défi, nous allons essayer de répondre à la question suivante : **quelle est l'effet de différentes épices sur la taille des flammes de trois espèces de dragons ?**

<br>

Commençons par importer les données :

```{r, echo=TRUE, eval=FALSE}
dragons <- read.csv("https://raw.githubusercontent.com/codons-blog/C-02-ManipulationDonnees/main/dragons.csv")
```

<br>

Voici les **objectifs** de ce défi :

-   mettre en forme les données (format tidy)

-   créer un boxplot pour chaque espèce montrant l'effet des épices sur la taille des flammes

<br>

Malheureusement, vous apprenez que votre assistant a été peu scrupuleux lors de la collecte des données, et il vous faut **corriger les erreurs suivantes** :

1.  La quatrième épice n'était pas du paprika, mais du curcuma\
2.  Lors des mesures avec le tabasco, l'appareil était mal calibré, mais seulement pour les Magyar à pointes : la taille des flammes a été sur-estimée de 30 cm\
3.  Les tailles sont données en centimètres, alors qu'elles devraient être en mètres.

<br>

**A votre tour de jouer!**

<br>

Si vous êtes coincé, vous pouvez cliquer ci-dessous pour afficher **quelques astuces** :

```{r, eval=FALSE, echo=TRUE, code_folding=TRUE}
# 1. Pour renommer la colonne "paprika", utilisez la fonction rename()

# 2. Il existe plusieurs facons de corriger des valeurs :

valeurs_corrigees <- dragons$tabasco[dragons$espece == "magyar_a_pointe"] - 30
dragons$tabasco[dragons$espece == "magyar_a_pointe"] <- valeurs_corrigees

dragons <- dragons %>% 
  mutate(tabasco = ifelse(espece == "magyar_a_pointe", tabasco - 30, tabasco))

dragons <- dragons %>% 
  mutate(tabasco = case_when(espece == "magyar_a_pointe" ~ tabasco - 30,
                             TRUE ~ tabasco))

# 3. La fonction mutate() vous permettra de convertir les centimètres en mètres
```

<br>

**Cliquez ci-dessous pour voir la solution**

```{r, eval=FALSE, echo=TRUE, code_folding=TRUE}
# Importer les donnees

dragons <- read_csv("https://raw.githubusercontent.com/codons-blog/C-02-ManipulationDonnees/main/dragons.csv")

# Nettoyer et corriger les donnees

dragons_tidy <- dragons %>% 
  rename(curcuma = paprika) %>% 
  pivot_longer(cols = tabasco:curcuma,
               names_to = "epice",
               values_to = "flamme_cm") %>% 
  mutate(flamme_cm = case_when(espece == "magyar_a_pointes" & epice == "tabasco" ~ flamme_cm - 30,
                               TRUE ~ flamme_cm)) %>% 
  mutate(flamme_m = flamme_cm / 100)

magyar_a_pointes <- dragons_tidy %>% filter(espece == "magyar_a_pointes")
suedois_a_museau_court <- dragons_tidy %>% filter(espece == "suedois_a_museau_court")
vert_gallois <- dragons_tidy %>% filter(espece == "vert_gallois")

# Boxplots

par(mfrow = c(1, 3))

boxplot(flamme_m ~ epice,
        data = magyar_a_pointes,
        xlab = "Epice",
        ylab = "Longueur flamme (m)",
        main = "Magyar à pointes")

boxplot(flamme_m ~ epice,
        data = suedois_a_museau_court,
        xlab = "Epice",
        ylab = "Longueur flamme (m)",
        main = "Suédois à museau court")

boxplot(flamme_m ~ epice,
        data = vert_gallois,
        xlab = "Epice",
        ylab = "Longueur flamme (m)",
        main = "Vert gallois")
```
