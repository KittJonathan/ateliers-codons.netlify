{
  "hash": "85757e8017a0e6a8802d2e4eb2fe448c",
  "result": {
    "markdown": "---\ntitle-block-banner: img/pexels-felix-mittermeier-956999.jpg\ntitle: \"Introduction au Tidyverse\"\nsubtitle: \"Utiliser le Tidyverse pour manipuler des données\"\nauthor:\n  - Sandra Angers-Blondin\n  - Jonathan Kitt (adaptation)\ndate: \"2022-10-24\"\ncategories: [R, RStudio, Tidyverse]\n# image: \"pexels-marta-branco-1194713.jpg\"\nformat: \n  html: \n    toc: true\n    toc-depth: 2\n    toc-title: \"Sommaire\"\n---\n\n\n*Ce tutoriel est adapté de [Basic data manipulation](https://ourcodingclub.github.io/tutorials/data-manip-intro/index.html) et [Efficient data manipulation](https://ourcodingclub.github.io/tutorials/data-manip-efficient/) du site [Our Coding Club](https://ourcodingclub.github.io/).*\n\n<br>\n\n::: {.callout-note icon=\"true\"}\n## Liens vers les autres tutoriels\n\n[Installer R et RStudio](https://ateliers-codons.netlify.app/posts/01-installer-r-et-rstudio/)\n\n[Premiers pas avec R](https://ateliers-codons.netlify.app/posts/02-premiers-pas-avec-r/)\n\n:::\n\n# Introduction\n\n\n<br>\n\nLes formats de nos données peuvent varier, et un format utile et pratique dans un cas précis ne le sera pas forcément dans un autre. La **maîtrise des outils de manipulation et de mise en forme des données** est donc essentielle !\n\n<br>\n\n## Qu'est-ce que le Tidyverse ?\n\n![Allison Horst](img/tidyverse_celestial.png){width=\"25%\"}\n\nLe [**Tidyverse**](https://www.tidyverse.org/) est un ensemble de packages permettant : \n\n- d'**importer** et d'**exporter** des données (package `readr`)  \n- de **manipuler** des données (package `dplyr`)  \n- de **mettre en forme** des données (package `tidyr`)  \n- de créer des **graphiques** (package `ggplot2`)  \n- de manipuler des **chaînes** (package `stringr`)  \n- de manipuler des **facteurs** (package `forcats`)  \n- de manipuler des **dates** (package `lubridate`)\n\n::: {.callout-tip icon=\"true\"}\n## Les packages\n\nUn package R contient permet d'apporter des fonctionnalités supplémentaires. Il existe des packages pour tout un tas d'applications. \n\n:::\n\n<br>\n\n## Organiser son travail\n\n- [Créez un nouveau projet](https://ateliers-codons.netlify.app/posts/02-premiers-pas-avec-r/#créer-un-projet)  \n\n- [Créez l'arborescence](https://ateliers-codons.netlify.app/posts/02-premiers-pas-avec-r/#créer-une-arborescence)  \n\n- [Ouvrez un nouveau script](https://ateliers-codons.netlify.app/posts/02-premiers-pas-avec-r/#le-script) et remplissez l'en-tête (voir ci-dessous)\n\n![](img/intro_tidyverse_01.png){width=\"100%\"}\n\n## Installer et charger le Tidyverse\n\nLa fonction `install.packages()` permet de télécharger un package. Une fois téléchargé, il vous faudra charger le package dans votre session (pour rendre ses fonctions disponibles) à l'aide de la fonction `library()` : \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Telecharger le Tidyverse\ninstall.packages(\"tidyverse\")\n\n# Charger le package\nlibrary(tidyverse)\n```\n:::\n\n\n::: {.callout-important icon=\"true\"}\n## Attention aux guillemets\n\nVous remarquerez la présence de guillemets dans l'appel à la fonction `install.packages()` et leur absence dans l'appel à la fonction `library()`.\n:::\n\nVous pourriez également n'installer et ne charger que les packages qui vous intéressent (par exemple `readr` et `dplyr`), plutôt que la suite complète.\n\n<br>\n\n# Exploration du Tidyverse\n\n## Importer les données\n\nLes fonctions proposées dans les différents packages de la suite Tidyverse sont - en règle générale - nommées d'après les actions qu'elles accomplissent, ce qui rend leur mémorisation plus simple et leur utilisation plus intuitive.\n\nNous allons utiliser le même [jeu de données](https://ateliers-codons.netlify.app/posts/02-premiers-pas-avec-r/) que dans le tutoriel [Premiers pas avec R](https://ateliers-codons.netlify.app/posts/02-premiers-pas-avec-r/).\n\n- Si vous aviez téléchargé ces données précédemment, copiez-les dans le dossier `raw()` et importez-les : \n\n\n::: {.cell}\n\n```{.r .cell-code}\npingouins <- read_csv(\"raw/pingouins.csv\")\n```\n:::\n\n\n- Vous pouvez également télécharger directement les données depuis leur emplacement en ligne : \n\n\n::: {.cell}\n\n```{.r .cell-code}\npingouins <- read_csv(\"https://raw.githubusercontent.com/codons-blog/C-02-ManipulationDonnees/main/pingouins.csv\")\n```\n:::\n\n\n::: {.callout-caution icon=\"true\"}\n## Bonne pratique : package + fonction\n\nDans le tutoriel [Premiers pas avec R](https://ateliers-codons.netlify.app/posts/02-premiers-pas-avec-r/) nous avions utilisé la fonction `read.csv()` pour importer les données, alors qu'ici nous utilisons la fonction `read_csv()`. Ces deux fonctions effectuent la même opération mais font partie de deux packages différents : le package `{utils}` pour `read.csv()` et le package `{readr}` pour `read_csv`. Si votre script est amené à être partagé, il est utile de préciser à quels packages vous faites appel, en utilisant la syntaxe `nom-du-package::nom-de-la-fonction()`. Dans notre exemple, il faudrait écrire `readr::read_csv()`. \n:::\n\n\nIl est toujours utile de **visualiser vos données** et leur structure : \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Exploration rapide des donnees ----\n\nhead(croissance)  # affiche les premieres lignes\nstr(croissance)  # types des variables\nunique(croissance$Zone)  # affiche les valeurs distinctes de la variable Zone\ncroissance$Indiv  # affiche toutes les valeurs de la variable Indiv\nlength(unique(croissance$Indiv))  # affiche le nombre d'individus\n```\n:::\n\n\n<br>\n\nLorsque vous exécutez la commande `head(croissance)`, vous pouvez remarquer dans la console la mention \"A tibble\". Un [**tibble**](https://tibble.tidyverse.org/index.html) est un format particulier de tableau utilisé dans le Tidyverse. Il présente notamment l'avantage d'afficher les **types de variables** sous les noms de colonnes. \n\n<br>\n\n## Renommer des variables avec `rename()` {#rename}\n\nCette fonction s'utilise de la façon suivante : `rename(objet, nouveau_nom = ancien_nom)`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Supprimer les majuscules dans les noms de colonnes\ncroissance <- rename(croissance,\n                      zone = Zone,\n                      indiv = Indiv)\n```\n:::\n\n\n<br>\nAvant d'aller plus loin, nous allons voir une fonctionnalité extrêmement pratique : **le \"pipe\"**. Un pipe permet d'enchaîner les opérations, et présente plusieurs avantages, notamment de rendre le **code plus clair et lisible** et de rendre possible l'**auto-complétion** (à l'aide de la touche `Tab`).  \n\nLe pipe fait partie du package [`magrittr`](https://magrittr.tidyverse.org/), inclus dans le Tidyverse.  \n\nUn pipe se place à la fin d'un ligne sous la forme `%>%` : \n\n<aside>\nRaccourci clavier : `Ctrl + Shift + M`\n</aside>\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncroissance <- croissance %>% \n  rename(zone = Zone,\n         indiv = Indiv)\n```\n:::\n\n\n<br>\n\n## Sélectionner des colonnes avec `select()` {#select}\n\nCette fonction permet de sélectionner des colonnes, en précisant lesquelles conserver ou supprimer : \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Conserver des colonnes\n\ncroissance_selection <- croissance %>% \n  select(indiv, `2007`:`2012`)\n\n# Supprimer une colonne\n\ncroissance_selection <- croissance %>% \n  select(-zone)\n```\n:::\n\n\n<br>\n\nLa fonction `select()` permet également de **renommer des colonnes** et d'**en modifier l'ordre** : \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Renommer et modifier l'ordre de colonnes\n\ncroissance_selection <- croissance %>% \n  select(zone = Zone, indiv = Indiv, `2007`:`2012`)\n```\n:::\n\n\n<br>\n\nL'opérateur `:` permet de construire une **séquence** : dans le cas présent il permet de sélectionner toutes les colonnes entre 2007 et 2012.  \n\nSi vous souhaitez renommer ou déplacer seulement quelques colonnes, la fonction `everything()` vous permet de **sélectionner toutes les colonnes restantes** : \n\n\n::: {.cell}\n\n```{.r .cell-code}\ncroissance_selection <- croissance %>% \n  select(zone = Zone, indiv = Indiv, everything())\n```\n:::\n\n\n<br>\n\n## Filtrer des données avec `filter()` {#filter}\n\nCette fonction permet de sélectionner des lignes à l'aide d'**opérateurs logiques** : \n\nOpérateur   Expression logique\n----------  -------------------\n==          strictement égal à\n<=          inférieur ou égal à\n<           inférieur à\n>=          supérieur ou égal à\n>           supérieur à\n!=          différent de\n%in%        appartient à\n&           et\n|           ou\n!           pas  \n\nVoyons comment utiliser ces opérateurs logiques : \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# individu n°603\n\ncroissance %>% filter(indiv == 603)\n\n# zones 2, 3 et 4\n\ncroissance %>% filter(zone <= 4)\ncroissance %>% filter(zone %in% c(2, 3, 4))\ncroissance %>% filter(zone %in% 2:4)\ncroissance %>% filter(!zone >= 5)\n\n# zones 2 et 7\n\ncroissance %>% filter(zone == 2 | zone == 7)\ncroissance %>% filter(zone %in% c(2, 7))\n\n# zone 2 + individus entre 300 et 400\n\ncroissance %>% filter(zone == 2 & indiv %in% 300:400)\ncroissance %>% filter(zone == 2 & between(indiv, 300, 400))\n```\n:::\n\n\n<br>\n\nIl existe différentes façons de **construire une séquence** :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseq(from = 300, to = 400, by = 10)  # de 300 a 400 avec un increment de 10\nrep(x = c(300, 350), times = 2)  # 2 repetitions du vecteur \"300, 350\"\nrep(x = c(300, 350), each = 2)  # chaque element du vecteur \"300, 350\" est repete 2 fois\nrep(seq(from = 300, to = 400, by = 10), times = 4)  # combinaison des deux\n```\n:::\n\n\n<br>\n\n## Trier des données avec `arrange()` {#arrange}\n\nLa fonction `arrange()` permet de trier des valeurs par **ordre croissant ou décroissant** : \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Trier par ordre croissant sur l'annee 2007\n\ncroissance %>% arrange(`2007`)\n\n# Trier par ordre decroissant sur l'annee 2008\n\ncroissance %>% arrange(desc(`2008`))\n```\n:::\n\n\n<br>\n\n## Créer de nouvelles colonnes avec `mutate()` {#mutate}\n\nLa fonction `mutate()` permet de créer un nouvelle colonne :\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calculer la croissance totale pour chaque individu entre 2007 et 2012\n\ncroissance_totale <- croissance %>% \n  mutate(croissance.totale = `2007` + `2008` + `2009` + `2010` + `2011` + `2012`)\n```\n:::\n\n\n<br>\n\n## Définir des groupes avec `group_by()` {#groupby}\n\nCette fonction permet de créer une **structure interne à vos données**, par exemple des individus regroupés par zone. Les fonctions exécutées après l'appel à la fonction `group_by()` tiendront compte de cette structure interne. L'utilisation de la fonction `group_by()` associée à d'autres fonctions est très utile pour calculer des statistiques pour différents sites, traitements, espèces, ...\n \n\n::: {.cell}\n\n```{.r .cell-code}\n# Grouper les individus par zone\n\ncroissance_groupes <- croissance %>% \n  group_by(zone)\n```\n:::\n\n\n<br>\n\nComparez les deux objets `croissance` et `croissance_groupes`. La seule différence visible est la mention `Groups` quand vous affichez l'objet possédant une structure interne. Pour l'instant, les groupes créés par `group_by()` sont **sous-jacents**, et leur intérêt sera évident en appliquant d'autres fonctions à ces groupes.\n\n<br>\n\n## Agréger des lignes et calculer des statistiques avec `summarise()` {#summarise}\n\nCette fonction permet d'agréger des lignes en appliquant une fonction sur une ou plusieurs colonnes :\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Croissance totale pour l'ensemble des individus pour l'annee 2007\n\nsynthese1 <- croissance %>% \n  summarise(croissance.totale.2007 = sum(`2007`))\n\n# Croissance totale pour l'ensemble des individus groupes par zone pour l'annee 2007\n\nsynthese2 <- croissance_groupes %>% \n  summarise(croissance.totale.2007 = sum(`2007`))\n```\n:::\n\n\n<br>\n\nLe premier objet, `synthese1`, correspond à la somme de toutes les valeurs de croissance pour tous les individus en 2007.\nLe second objet, `synthese2`, correspond à la somme des valeurs de croissance pour les individus regroupés par zone en 2007.\n\n<aside>\nLes données étant agrégées, le tableau de sortie sera plus court que les données d'origine.\n</aside>\n\nVous pouvez de cette façon calculer plusieurs paramètres : \n\n\n::: {.cell}\n\n```{.r .cell-code}\nsynthese3 <- croissance_groupes %>% \n  summarise(croissance.totale.2007 = sum(`2007`),\n            croissance.moyenne.2007 = mean(`2007`),\n            croissance.ecart.type.2007 = sd(`2007`)) \n```\n:::\n\n\n<br>\n\n## Joindre des données avec `..._join()` {#join}\n\nIl peut arriver que des données concernant un même projet se trouvent dans **plusieurs fichiers** (par exemple un fichier avec des mesures sur différents sites, et un autre fichier avec des données climatiques pour ces différents sites).  \n\n<br>\n\nLes différentes fonctions `..._join()` permettent de joindre plusieux jeux de données selon ce qu'on souhaite faire des données qui ne sont pas partagées.\nLes lignes d'un tableau seront associées à l'autre tableau selon les valeurs d'une ou de plusieurs colonnes partagées (les **clés**).\n\n# ```{r, layout=\"l-body\"}\n# knitr::include_graphics(\"img/join-venn.png\")\n# ```\n# Figure tirée de [R for Data Science](https://r4ds.had.co.nz/relational-data.html)\n\n<br>\n\nLe fichier `traitements.csv` contient des informations sur des **traitements appliqués aux plantes** : températe (T), fertilisation (F), température + fertilisation (TF), ou contrôle (C).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Importer le jeu de données (attention : utilisation de read_csv2)\n\ntraitements <- read_csv2(\"https://raw.githubusercontent.com/codons-blog/C-02-ManipulationDonnees/main/traitements.csv\")\n```\n:::\n\n\n<br>\n\nNous allons utiliser la fonction `left_join()` pour garder toutes les données présentes dans `croissance` et y associer les données présentes dans `traitements` : \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Joindre deux jeux de données\n\nexpe <- croissance %>% \n  left_join(traitements,\n            by = c(\"zone\" = \"Zone\",\n                   \"indiv\" = \"Indiv\"))\n```\n:::\n\n\n<br>\n\nSi les noms des deux premières colonnes avaient été strictement identiques dans les deux tableaux, nous aurions pu nous passer de l'argument `by()`.\n\n<br>\n\n# Mettre en forme des données à l'aide de `tidyr` {#tidyr}\n\nLes données que nous avons manipulées jusqu'à présent ne sont **pas dans un format idéal** (rappelez-vous la longueur du code pour calculer la croissance totale pour chaque individu).  \n\nLes valeurs mesurées sont réparties dans différentes colonnes, une par année.  \n\nNous pourrions mettre en forme ces donnes afin d'avoir une colonne \"annee\" et une colonne \"croissance\".  \n\nC'est ce qu'on appelle des **tidy data**, concept qui repose sur trois critères :  \n\n**1. Chaque variable est située dans sa propre colonne**  \n**2. Chaque observation est située sur sa propre ligne**  \n**3. Chaque valeur est située dans sa propre cellule**\n  \n# ```{r, layout=\"l-body\"}\n# knitr::include_graphics(\"img/tidy-1.png\")\n# ```\n# Figure tirée de [R for Data Science](https://r4ds.had.co.nz/tidy-data.html)\n\n<br>\n\nConsidérons les deux premières lignes de notre tableau `croissance`, voici à quoi ressemblerait un format **tidy** : \n\n# ```{r, layout=\"l-body-outset\"}\n# knitr::include_graphics(\"img/tidy_data.png\")\n# ```\n\n<br>\n\nCe format **facilite les analyses** en permettant des comparaisons entre groupes, traitements, espèces, années, ...  \n\nLe package `tidyr` permet de jongler entre ces deux formats grâce aux fonctions `pivot_...()`.\n\n# ```{r, layout=\"l-body\"}\n# knitr::include_graphics(\"img/giphy.gif\")\n# ```\n\n<br>\n\n## Format long avec `pivot_longer()`\n\nLa fonction `pivot_longer()` permet de passer d'un format large à un format long. La syntaxe est un peu plus complexe que les fonctions que nous avons vues jusqu'à présent, car il nous préciser quelles colonnes vont être regroupées : \n\n# ```{r, layout=\"l-body-outset\"}\n# knitr::include_graphics(\"img/pivot_longer.png\")\n# ```\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Format large -> format long\n\ncroissance_long <- croissance %>% \n  pivot_longer(cols = `2007`:`2012`,\n               names_to = \"annee\",\n               values_to = \"croissance\")\n```\n:::\n\n\n<br>\n\n## Format large avec `pivot_wider()`\n\nCette fonction permet d'effectuer l'opération inverse : \n\n# ```{r, layout=\"l-body-outset\"}\n# knitr::include_graphics(\"img/pivot_wider.png\")\n# ```\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Format long -> format large\n\ncroissance_large <- croissance_long %>% \n  pivot_wider(id_cols = zone:indiv,\n              names_from = annee,\n              values_from = croissance)\n```\n:::\n\n\n<br>\n\nDans les arguments `names_from` et `values_from` nous n'utilisons pas de guillemets car ces colonnes existent, contraitement aux arguments `names_to` et `values_to` de la fonction `pivot_longer()` qui permettent de créer des colonnes inexistantes.\n\n<br>\n\n## Résumé\n\nNous avons vu les principales fonctions des packages `dplyr` et `tidyr` une par une. Nous allons maintenant **enchaîner les différentes opérations** depuis le début à l'aide d'un `pipe` et **visualiser l'effet des différents traitements** sur la croissance des tiges d'*Empetrum* : \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Importer les deux fichiers\n\ncroissance <- read_csv(\"https://raw.githubusercontent.com/codons-blog/C-02-ManipulationDonnees/main/croissance.csv\")\ntraitements <- read_csv2(\"https://raw.githubusercontent.com/codons-blog/C-02-ManipulationDonnees/main/traitements.csv\")\n\n# Mettre en forme et joindre les deux fichiers\n\nexpe <- croissance %>% \n  pivot_longer(cols = `2007`:`2012`,\n               names_to = \"annee\",\n               values_to = \"croissance\") %>% \n  left_join(traitements) %>% \n  rename(zone = Zone,\n         indiv = Indiv,\n         traitement = Traitement) %>% \n  mutate(zone = as.factor(zone),\n         indiv = as.factor(indiv),\n         annee = as.numeric(annee),\n         traitement = as.factor(traitement))\n\n# Boxplot de l'effet des traitements sur la croissance\n\nboxplot(croissance ~ traitement, \n        data = expe,\n        main = \"Effet de la température (T) et de la fertilisation (F) sur la croissance d'Empetrum\",\n        xlab = \"Traitement\",\n        ylab = \"Croissance des tiges (cm)\")\n```\n:::\n\n\n<br>\n\n# ```{r, layout=\"l-body-outset\"}\n# knitr::include_graphics(\"img/boxplot.png\")\n# ```\n\n<br>\n\n## Bilan du tutoriel : \n\n1. Vous savez utiliser les fonctions de `dplyr` pour manipuler vos données  \n2. Vous savez mettre en forme des données qui respectent les critères des tidy data avec `tidyr`\n\n<br>\n\n\n# Défi {#defi}\n\nPour ce défi, nous allons essayer de répondre à la question suivante : **quelle est l'effet de différentes épices sur la taille des flammes de trois espèces de dragons ? **\n\n<br>\n\nCommençons par importer les données : \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndragons <- read.csv(\"https://raw.githubusercontent.com/codons-blog/C-02-ManipulationDonnees/main/dragons.csv\")\n```\n:::\n\n\n<br>\n\nVoici les **objectifs** de ce défi :  \n\n- mettre en forme les données (format tidy)  \n\n- créer un boxplot pour chaque espèce montrant l'effet des épices sur la taille des flammes  \n\n<br>\n\nMalheureusement, vous apprenez que votre assistant a été peu scrupuleux lors de la collecte des données, et il vous faut **corriger les erreurs suivantes** : \n\n1. La quatrième épice n'était pas du paprika, mais du curcuma  \n2. Lors des mesures avec le tabasco, l'appareil était mal calibré, mais seulement pour les Magyar à pointes : la taille des flammes a été sur-estimée de 30 cm  \n3. Les tailles sont données en centimètres, alors qu'elles devraient être en mètres.\n\n<br>\n\n**A votre tour de jouer!**\n\n<br>\n\nSi vous êtes coincé, vous pouvez cliquer ci-dessous pour afficher **quelques astuces** : \n\n\n::: {.cell code_folding='true'}\n\n```{.r .cell-code}\n# 1. Pour renommer la colonne \"paprika\", utilisez la fonction rename()\n\n# 2. Il existe plusieurs facons de corriger des valeurs :\n\nvaleurs_corrigees <- dragons$tabasco[dragons$espece == \"magyar_a_pointe\"] - 30\ndragons$tabasco[dragons$espece == \"magyar_a_pointe\"] <- valeurs_corrigees\n\ndragons <- dragons %>% \n  mutate(tabasco = ifelse(espece == \"magyar_a_pointe\", tabasco - 30, tabasco))\n\ndragons <- dragons %>% \n  mutate(tabasco = case_when(espece == \"magyar_a_pointe\" ~ tabasco - 30,\n                             TRUE ~ tabasco))\n\n# 3. La fonction mutate() vous permettra de convertir les centimètres en mètres\n```\n:::\n\n\n<br>\n\n**Cliquez ci-dessous pour voir la solution**\n\n\n::: {.cell code_folding='true'}\n\n```{.r .cell-code}\n# Importer les donnees\n\ndragons <- read_csv(\"https://raw.githubusercontent.com/codons-blog/C-02-ManipulationDonnees/main/dragons.csv\")\n\n# Nettoyer et corriger les donnees\n\ndragons_tidy <- dragons %>% \n  rename(curcuma = paprika) %>% \n  pivot_longer(cols = tabasco:curcuma,\n               names_to = \"epice\",\n               values_to = \"flamme_cm\") %>% \n  mutate(flamme_cm = case_when(espece == \"magyar_a_pointes\" & epice == \"tabasco\" ~ flamme_cm - 30,\n                               TRUE ~ flamme_cm)) %>% \n  mutate(flamme_m = flamme_cm / 100)\n\nmagyar_a_pointes <- dragons_tidy %>% filter(espece == \"magyar_a_pointes\")\nsuedois_a_museau_court <- dragons_tidy %>% filter(espece == \"suedois_a_museau_court\")\nvert_gallois <- dragons_tidy %>% filter(espece == \"vert_gallois\")\n\n# Boxplots\n\npar(mfrow = c(1, 3))\n\nboxplot(flamme_m ~ epice,\n        data = magyar_a_pointes,\n        xlab = \"Epice\",\n        ylab = \"Longueur flamme (m)\",\n        main = \"Magyar à pointes\")\n\nboxplot(flamme_m ~ epice,\n        data = suedois_a_museau_court,\n        xlab = \"Epice\",\n        ylab = \"Longueur flamme (m)\",\n        main = \"Suédois à museau court\")\n\nboxplot(flamme_m ~ epice,\n        data = vert_gallois,\n        xlab = \"Epice\",\n        ylab = \"Longueur flamme (m)\",\n        main = \"Vert gallois\")\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}