{
  "hash": "d270b1c93de46ef679f05bf64f145bb6",
  "result": {
    "markdown": "---\ntitle: \"Introduction au Tidyverse\"\nsubtitle: \"Utiliser le Tidyverse pour manipuler des données\"\nauthor:\n  - Sandra Angers-Blondin\n  - Jonathan Kitt (adaptation)\ndate: \"2022-10-24\"\ndraft: false\ncategories: [R, RStudio, Tidyverse]\nformat: \n  html: \n    toc: true\n    toc-depth: 2\n    toc-title: \"Sommaire\"\n---\n\n\n\n\n\n*Ce tutoriel est adapté de [Basic data manipulation](https://ourcodingclub.github.io/tutorials/data-manip-intro/index.html) et [Efficient data manipulation](https://ourcodingclub.github.io/tutorials/data-manip-efficient/) du site [Our Coding Club](https://ourcodingclub.github.io/).*\n\n<br>\n\n# Introduction\n\n## Qu'est-ce que le Tidyverse ?\n\nLe [Tidyverse](https://www.tidyverse.org/) est un ensemble de packages proposant de multiples fonctions utiles à l'ensemble des étapes d'une analyse :   \n\n|                                               |                                       |\n| :-------------------------------------------- | :------------------------------------ |\n| [readr](https://readr.tidyverse.org/)         | importer et exporter les données      |\n| [tibble](https://tibble.tidyverse.org/)       | format de tableau propre au tidyverse |\n| [dplyr](https://dplyr.tidyverse.org/)         | manipuler les données                 |\n| [tidyr](https://tidyr.tidyverse.org/)         | transformer des tableaux              |\n| [stringr](https://stringr.tidyverse.org/)     | manipuler des chaînes de caractères   |\n| [forcats](https://forcats.tidyverse.org/)     | manipuler des variables catégorielles |\n| [ggplot2](https://ggplot2.tidyverse.org/)     | représenter les données               |\n| [purrr](https://purrr.tidyverse.org/)         | programmation fonctionnelle           |\n| [lubridate](https://lubridate.tidyverse.org/) | manipuler des dates                   |\n\n<br>\n\n## Pré-requis\n\nSi vous n'avez pas suivi les autres tutoriels, vous pouvez [créer un projet RStudio](https://ateliers-codons.netlify.app/posts/02-premiers-pas-avec-r/#créer-un-projet) et [une arborescence](https://ateliers-codons.netlify.app/posts/02-premiers-pas-avec-r/#créer-une-arborescence).\n\nPour utiliser le Tidyverse, vous pouvez soit installer et charger séparément les packages dont vous aurez besoin, soit installer et charger directement la suite complète : \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Installer et charger les packages readr et dplyr\ninstall.packages(c(\"readr\", \"dplyr\"))\nlibrary(readr)\nlibrary(dplyr)\n\n# Installer et charger la suite Tidyverse\ninstall.packages(\"tidyverse\")\nlibrary(tidyverse)\n```\n:::\n\n\n::: {.callout-caution icon=\"true\"}\n## Les conflits\n\nLorsque vous exécutez la fonction `library(tidyverse)`, le message suivant s'affiche dans la console : \n\n![](img/tidyverse_intro_01.png)\n\nR vous indique : \n\n- le nom et la version des packages individuels (*Attaching packages*)    \n- les fonctions portant des noms identiques existant dans d'autres packages (*Conflicts*)\n\nIl existe par exemple une fonction `filter()` dans le package `stats`. Si vous souhaitez utiliser cette dernière fonction plutôt que celle proposée dans le package `dplyr`, il vous foudra préciser le package en question : `stats::filter()`.\n\n:::\n\n<br>\n\n# Premiers pas dans le Tidyverse\n\nLes fonctions proposées dans les différents packages de la suite Tidyverse sont - en règle générale - nommées d'après les actions qu'elles accomplissent, ce qui rend leur mémorisation plus simple et leur utilisation plus intuitive.\n\n\n## Importer les données\n\nNous allons utiliser le même jeu de données que dans les tutoriels précédents (vous pouvez le télécharger [ici](https://raw.githubusercontent.com/codons-blog/ateliers-codons.netlify/main/raw/pingouins.csv) et le sauvegarder dans votre dossier `raw/`).\n\nPour importer les données, nous utilisons la fonction `read_csv()`, à ne pas comprendre avec la fonction `read.csv()` utilisée précédemment.\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npingouins <- read_csv(file = \"raw/pingouins.csv\")\n```\n:::\n\n\nVous pouvez voir dans la console des informations concernant vos données :  \n- les *dimensions* du tableau    \n- le *séparateur* de colonnes  \n- les *types* et les *noms* des variables  \n\n<br>\n\nTapez `pingouins` dans la console et appuyze sur `Entrée` : vos données s'affichent et vous pouvez voir qu'il s'agit d'un *tibble*, qui présente quelques particularités par rapport à un tableau \"classique\" : \n\n- les dimensions du *tibble* sont précisées  \n- les *types* des variables sont indiquées sous les noms des colonnes  \n- seules les *dix premières lignes* sont affichées  \n- le nombre de colonnes affichées dépend de la largeur de l'écran  \n- les noms de colonnes sont raccourcis si nécessaire  \n- les données manquantes *NA* sont mises en évidence\n\nPour bien voir la différence entre un `tibble` et un `data.frame`, comparez les deux commandes suivantes : \n\n\n::: {.cell}\n\n```{.r .cell-code}\npingouins\nas.data.frame(pingouins)\n```\n:::\n\n\n<br>\n\n## Explorer les données\n\nPlusieurs fonctions incluses dans R permettent d'explorer rapidement des données pour s'assurer qu'elles ont été correctement importées : \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Afficher les premieres lignes\nhead(pingouins)\n\n# Afficher les dernieres lignes\ntail(pingouins)\n\n# Afficher la structure des donnees\nstr(pingouins)\n```\n:::\n\n\nLa fonction `glimpse()` (du package `readr`) retourne sensiblement les mêmes informations que la fonction `str()` : \n\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(pingouins)\n```\n:::\n\n\n<br>\n\n## Créer une copie de travail\n\nLa première chose à faire avant de manipuler, modifier et transformer nos données est de créer une copie de travail : cela nous permettra, en cas d'erreur, de repartir des données d'origines.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npingouins_tmp <- pingouins\n```\n:::\n\n\n<br>\n\n## Renommer des colonnes\n\nCommençons par renommer des colonnes afin de respecter les conventions d'écriture :\n\n- *snake_case* : caractères minuscules, mots séparés par des `_`  \n- *camelCase* : aucune séparation entre les mots, majuscule pour débuter un mot\n\nLa fonction `rename` s'utilise de la façon suivante : `rename(data, nouveau nom = ancien nom)`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrename(pingouins_tmp, ile = Ile)\n```\n:::\n\n\nNous pourrions procéder de la même façon pour plusieurs colonnes à la fois : \n\n\n::: {.cell}\n\n```{.r .cell-code}\nrename(pingouins_tmp, espece = Espece, ile = Ile)\n```\n:::\n\n\n<br>\n\nLe package [`janitor`](https://cran.r-project.org/web/packages/janitor/vignettes/janitor.html) est dédié au nettoyage d'un tableau (noms de colonnes, suppression des doublons, ...). Utilisons la fonction `clean_names()` de ce package :\n\n\n::: {.cell}\n\n```{.r .cell-code}\njanitor::clean_names(pingouins_tmp)\n```\n:::\n\n\nAssignons ces noms de colonnes nettoyés à notre copie de travail : \n\n\n::: {.cell}\n\n```{.r .cell-code}\npingouins_tmp <- janitor::clean_names(pingouins_tmp)\n```\n:::\n\n\nAssurons-nous que les noms de colonnes ont bien été modifiés : \n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(pingouins_tmp)\n```\n:::\n\n\n<br>\n\n::: {.callout-tip icon=\"true\"}\n## Explorer les arguments d'une fonction\n\nPour afficher l'aide de la fonction `clean_names`, tapez `?clean_names` (ou `?janitor::clean_names`) dans la console. Vous trouverez dans l'aide toutes les informations concernant une fonction. Dans notre cas, nous pourrions utiliser différentes conventions d'écriture pour nos noms de colonnes : `clean_names(pingouins_tmp, case = \"lower_camel\")` par exemple.\n\n:::\n\n<br>\n\n## Sélectionner des colonnes\n\nLa fonction `select()` permet de sélectionner les colonnes d'un tableau. Nous allons sélectionner les colonnes *espece*, *ile*, *longueur_bec_mm*, *hauteur_bec_mm*, *longueur_aile_mm* et *masse_corporelle_g*.\nNous pouvons procéder de plusieurs façons : \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Indiquer toutes les colonnes\nselect(pingouins_tmp, espece, ile, longueur_bec_mm, hauteur_bec_mm,\n       longueur_aile_mm, masse_corporelle_g)\n\n# Indiquer les suites de colonnes\nselect(pingouins_tmp, espece:ile, longueur_bec_mm:masse_corporelle_g)\n\n# Supprimer des colonnes\nselect(pingouins_tmp, espece:ile, longueur_bec_mm:masse_corporelle_g)\n```\n:::\n\n\nD'autres fonctions du package `dplyr` permettent de sélectionner des colonnes : \n\n- `contains()` : sélectionner les noms de colonnes qui contiennent un motif  \n- `starts_width()` : sélectionner les noms de colonnes qui commencent par un motif  \n- `ends_width()` : sélectionner les noms de colonnes qui se terminent par un motif\n\nDans notre cas, nous pouvons sélectionner les colonnes *espece* et *ile*, puis les colonnes dont le nom se termine par *mm* ou par *g* : \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Utiliser la fonction ends_with()\nselect(pingouins_tmp, espece, ile, ends_with(c(\"mm\", \"g\")))\n```\n:::\n\n\nAssignons cette sélection de colonnes à notre objet : \n\n\n::: {.cell}\n\n```{.r .cell-code}\npingouins_tmp <- select(pingouins_tmp, espece, ile, ends_with(c(\"mm\", \"g\")))\n```\n:::\n\n\n<br>\n\n::: {.callout-tip icon=\"true\"}\n## Renommer et ré-ordonner des colonnes avec `select()`\n\nNous pouvons utiliser la fonction `select()` pour renommer des colonnes : \n\n::: {.cell}\n\n```{.r .cell-code}\nselect(pingouins_tmp, espece:longueur_aile_mm, masse = masse_corporelle_g)\n```\n:::\n\n\nMais aussi pour modifier l'ordre des colonnes : \n\n::: {.cell}\n\n```{.r .cell-code}\nselect(pingouins_tmp, espece:ile, masse_corporelle_g, longueur_bec_mm:longueur_aile_mm)\n```\n:::\n\n\nEnfin, si nous n'avons que quelques colonnes à déplacer, la fonction `everything()` permet de sélectionner le reste du tableau ! \n\n::: {.cell}\n\n```{.r .cell-code}\nselect(pingouins_tmp, ile, everything())\n```\n:::\n\n\n\n:::\n\n<br>\n\n## Filtrer des données\n\nLa fonction `filter()` permet de filtrer les données à l'aide d'opérateurs logiques : \n\n|        |                     | \n| ------ | ------------------- |\n| `==`   | strictement égal à  |\n| `<=`   | inférieur ou égal à |\n| `<`    | inférieur à         |\n| `>=`   | supérieur ou égal à |\n| `>`    | supérieur à         |\n| `!=`   | différent de        |\n| `%in%` | appartient à        |\n| `&`    | et                  |\n| `|`    | ou                  |\n| `!`    | négation            |\n\nVoici deux exemples : \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Individus vivant sur l'ile Biscoe pesant au moins 5 kgs\nfilter(pingouins_tmp, ile == \"Biscoe\", masse_corporelle_g >= 5000)\n\n# Individus vivant sur les iles Biscoe ou Torgersen\nfilter(pingouins_tmp, ile %in% c(\"Biscoe\", \"Torgersen\"))\n```\n:::\n\n\nLa fonction `between()` permet de garder les valeurs numériques entre deux bornes : \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Individus pesant entre 3 kgs et 3,5 kgs\nfilter(pingouins_tmp, between(masse_corporelle_g, 3000, 3250))\n```\n:::\n\n\n<br>\n\nNotre jeu de données contient des données manquantes `NA`. Il existe plusieurs manières de supprimer ces données manquantes : \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Garder les lignes pour lesquelles la variable longueur_bec_mm ne contient pas de NA\nfilter(pingouins_tmp, !is.na(longueur_bec_mm))\n\n# Supprimer les lignes pour lesquelles la variable longueur_bec_mm contient au moins un NA\ndrop_na(pingouins_tmp, longueur_bec_mm)\n\n# Supprimer les lignes contenant des NAs, quelque soit la variable\ndrop_na(pingouins_tmp)\n```\n:::\n\n\n\n<br>\n\n## Trier des données\n\nLa fonction `arrange()` permet de trier des données. Par défaut, le tri s'effectue par ordre croissant. Pour trier des données par ordre décroissant, il faut ajouter la fonction `desc()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Trier les données par ordre croisant de longueur de bec\narrange(pingouins_tmp, longueur_bec_mm)\n\n# Trier les données par ordre décroissant de masse corporelle\narrange(pingouins_tmp, desc(masse_corporelle_g))\n```\n:::\n\n\nIl est possible de trier sur plusieurs colonnes : nous pouvons trier les individus par ordre décroissant de hauteur de bec puis par ordre décroissant de longueur de bec. Cela peut être utile pour départager des individus \"ex-aequo\" pour une variable : \n\n\n::: {.cell}\n\n```{.r .cell-code}\narrange(pingouins_tmp, desc(hauteur_bec_mm), desc(longueur_bec_mm))\n```\n:::\n\n\n## Créer ou modifier des colonnes \n\nLa fonction `mutate()` permet de créer une nouvelle colonne. Nous pouvons par exemple ajouter une colonne *ratio_bec* dans laquelle nous allons calculer le rapport entre la longueur du bec et sa hauteur : \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmutate(pingouins_tmp, ratio_bec = longueur_bec_mm / hauteur_bec_mm)\n```\n:::\n\n\nNous pouvons également modifier le contenu d'une colonne, par exemple en ajoutant le suffixe *island* au contenu de la colonne *ile* : \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmutate(pingouins_tmp, ile = paste0(ile, \" island\"))\n```\n:::\n\n\nLa fonction `transmute()` permet quant à elle de créer une nouvelle colonne tout en supprimant les colonnes pré-existantes : \n\n\n::: {.cell}\n\n```{.r .cell-code}\ntransmute(pingouins_tmp, masse_kgs = masse_corporelle_g / 1000)\n```\n:::\n\n\n\n<br> \n\nAvant d'aller plus loin, nous allons voir une fonctionnalité extrêmement pratique : **le \"pipe\"**. Un pipe permet d'enchaîner les opérations, et présente plusieurs avantages, notamment de rendre le **code plus clair et lisible** et de rendre possible l'**auto-complétion** (à l'aide de la touche `Tab`).\n\nLe pipe fait partie du package [`magrittr`](https://magrittr.tidyverse.org/), inclus dans le Tidyverse.\n\nUn pipe se place à la fin d'un ligne sous la forme `%>%` :\n\n<aside>Raccourci clavier : `Ctrl + Shift + M`</aside>\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncroissance <- croissance %>% \n  rename(zone = Zone,\n         indiv = Indiv)\n```\n:::\n\n\n\n\n<br>\n\n## Définir des groupes avec `group_by()` {#groupby}\n\nCette fonction permet de créer une **structure interne à vos données**, par exemple des individus regroupés par zone. Les fonctions exécutées après l'appel à la fonction `group_by()` tiendront compte de cette structure interne. L'utilisation de la fonction `group_by()` associée à d'autres fonctions est très utile pour calculer des statistiques pour différents sites, traitements, espèces, ...\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Grouper les individus par zone\n\ncroissance_groupes <- croissance %>% \n  group_by(zone)\n```\n:::\n\n\n<br>\n\nComparez les deux objets `croissance` et `croissance_groupes`. La seule différence visible est la mention `Groups` quand vous affichez l'objet possédant une structure interne. Pour l'instant, les groupes créés par `group_by()` sont **sous-jacents**, et leur intérêt sera évident en appliquant d'autres fonctions à ces groupes.\n\n<br>\n\n## Agréger des lignes et calculer des statistiques avec `summarise()` {#summarise}\n\nCette fonction permet d'agréger des lignes en appliquant une fonction sur une ou plusieurs colonnes :\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Croissance totale pour l'ensemble des individus pour l'annee 2007\n\nsynthese1 <- croissance %>% \n  summarise(croissance.totale.2007 = sum(`2007`))\n\n# Croissance totale pour l'ensemble des individus groupes par zone pour l'annee 2007\n\nsynthese2 <- croissance_groupes %>% \n  summarise(croissance.totale.2007 = sum(`2007`))\n```\n:::\n\n\n<br>\n\nLe premier objet, `synthese1`, correspond à la somme de toutes les valeurs de croissance pour tous les individus en 2007. Le second objet, `synthese2`, correspond à la somme des valeurs de croissance pour les individus regroupés par zone en 2007.\n\n<aside>Les données étant agrégées, le tableau de sortie sera plus court que les données d'origine.</aside>\n\nVous pouvez de cette façon calculer plusieurs paramètres :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsynthese3 <- croissance_groupes %>% \n  summarise(croissance.totale.2007 = sum(`2007`),\n            croissance.moyenne.2007 = mean(`2007`),\n            croissance.ecart.type.2007 = sd(`2007`)) \n```\n:::\n\n\n<br>\n\n## Joindre des données avec `..._join()` {#join}\n\nIl peut arriver que des données concernant un même projet se trouvent dans **plusieurs fichiers** (par exemple un fichier avec des mesures sur différents sites, et un autre fichier avec des données climatiques pour ces différents sites).\n\n<br>\n\nLes différentes fonctions `..._join()` permettent de joindre plusieux jeux de données selon ce qu'on souhaite faire des données qui ne sont pas partagées. Les lignes d'un tableau seront associées à l'autre tableau selon les valeurs d'une ou de plusieurs colonnes partagées (les **clés**).\n\n# `{r, layout=\"l-body\"} # knitr::include_graphics(\"img/join-venn.png\") #`\n\n# Figure tirée de [R for Data Science](https://r4ds.had.co.nz/relational-data.html)\n\n<br>\n\nLe fichier `traitements.csv` contient des informations sur des **traitements appliqués aux plantes** : températe (T), fertilisation (F), température + fertilisation (TF), ou contrôle (C).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Importer le jeu de données (attention : utilisation de read_csv2)\n\ntraitements <- read_csv2(\"https://raw.githubusercontent.com/codons-blog/C-02-ManipulationDonnees/main/traitements.csv\")\n```\n:::\n\n\n<br>\n\nNous allons utiliser la fonction `left_join()` pour garder toutes les données présentes dans `croissance` et y associer les données présentes dans `traitements` :\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Joindre deux jeux de données\n\nexpe <- croissance %>% \n  left_join(traitements,\n            by = c(\"zone\" = \"Zone\",\n                   \"indiv\" = \"Indiv\"))\n```\n:::\n\n\n<br>\n\nSi les noms des deux premières colonnes avaient été strictement identiques dans les deux tableaux, nous aurions pu nous passer de l'argument `by()`.\n\n<br>\n\n# Mettre en forme des données à l'aide de `tidyr` {#tidyr}\n\nLes données que nous avons manipulées jusqu'à présent ne sont **pas dans un format idéal** (rappelez-vous la longueur du code pour calculer la croissance totale pour chaque individu).\n\nLes valeurs mesurées sont réparties dans différentes colonnes, une par année.\n\nNous pourrions mettre en forme ces donnes afin d'avoir une colonne \"annee\" et une colonne \"croissance\".\n\nC'est ce qu'on appelle des **tidy data**, concept qui repose sur trois critères :\n\n**1. Chaque variable est située dans sa propre colonne**\\\n**2. Chaque observation est située sur sa propre ligne**\\\n**3. Chaque valeur est située dans sa propre cellule**\n\n# `{r, layout=\"l-body\"} # knitr::include_graphics(\"img/tidy-1.png\") #`\n\n# Figure tirée de [R for Data Science](https://r4ds.had.co.nz/tidy-data.html)\n\n<br>\n\nConsidérons les deux premières lignes de notre tableau `croissance`, voici à quoi ressemblerait un format **tidy** :\n\n# `{r, layout=\"l-body-outset\"} # knitr::include_graphics(\"img/tidy_data.png\") #`\n\n<br>\n\nCe format **facilite les analyses** en permettant des comparaisons entre groupes, traitements, espèces, années, ...\n\nLe package `tidyr` permet de jongler entre ces deux formats grâce aux fonctions `pivot_...()`.\n\n# `{r, layout=\"l-body\"} # knitr::include_graphics(\"img/giphy.gif\") #`\n\n<br>\n\n## Format long avec `pivot_longer()`\n\nLa fonction `pivot_longer()` permet de passer d'un format large à un format long. La syntaxe est un peu plus complexe que les fonctions que nous avons vues jusqu'à présent, car il nous préciser quelles colonnes vont être regroupées :\n\n# `{r, layout=\"l-body-outset\"} # knitr::include_graphics(\"img/pivot_longer.png\") #`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Format large -> format long\n\ncroissance_long <- croissance %>% \n  pivot_longer(cols = `2007`:`2012`,\n               names_to = \"annee\",\n               values_to = \"croissance\")\n```\n:::\n\n\n<br>\n\n## Format large avec `pivot_wider()`\n\nCette fonction permet d'effectuer l'opération inverse :\n\n# `{r, layout=\"l-body-outset\"} # knitr::include_graphics(\"img/pivot_wider.png\") #`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Format long -> format large\n\ncroissance_large <- croissance_long %>% \n  pivot_wider(id_cols = zone:indiv,\n              names_from = annee,\n              values_from = croissance)\n```\n:::\n\n\n<br>\n\nDans les arguments `names_from` et `values_from` nous n'utilisons pas de guillemets car ces colonnes existent, contraitement aux arguments `names_to` et `values_to` de la fonction `pivot_longer()` qui permettent de créer des colonnes inexistantes.\n\n<br>\n\n## Résumé\n\nNous avons vu les principales fonctions des packages `dplyr` et `tidyr` une par une. Nous allons maintenant **enchaîner les différentes opérations** depuis le début à l'aide d'un `pipe` et **visualiser l'effet des différents traitements** sur la croissance des tiges d'*Empetrum* :\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Importer les deux fichiers\n\ncroissance <- read_csv(\"https://raw.githubusercontent.com/codons-blog/C-02-ManipulationDonnees/main/croissance.csv\")\ntraitements <- read_csv2(\"https://raw.githubusercontent.com/codons-blog/C-02-ManipulationDonnees/main/traitements.csv\")\n\n# Mettre en forme et joindre les deux fichiers\n\nexpe <- croissance %>% \n  pivot_longer(cols = `2007`:`2012`,\n               names_to = \"annee\",\n               values_to = \"croissance\") %>% \n  left_join(traitements) %>% \n  rename(zone = Zone,\n         indiv = Indiv,\n         traitement = Traitement) %>% \n  mutate(zone = as.factor(zone),\n         indiv = as.factor(indiv),\n         annee = as.numeric(annee),\n         traitement = as.factor(traitement))\n\n# Boxplot de l'effet des traitements sur la croissance\n\nboxplot(croissance ~ traitement, \n        data = expe,\n        main = \"Effet de la température (T) et de la fertilisation (F) sur la croissance d'Empetrum\",\n        xlab = \"Traitement\",\n        ylab = \"Croissance des tiges (cm)\")\n```\n:::\n\n\n<br>\n\n# `{r, layout=\"l-body-outset\"} # knitr::include_graphics(\"img/boxplot.png\") #`\n\n<br>\n\n## Bilan du tutoriel :\n\n1.  Vous savez utiliser les fonctions de `dplyr` pour manipuler vos données\\\n2.  Vous savez mettre en forme des données qui respectent les critères des tidy data avec `tidyr`\n\n<br>\n\n# Défi {#defi}\n\nPour ce défi, nous allons essayer de répondre à la question suivante : **quelle est l'effet de différentes épices sur la taille des flammes de trois espèces de dragons ?**\n\n<br>\n\nCommençons par importer les données :\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndragons <- read.csv(\"https://raw.githubusercontent.com/codons-blog/C-02-ManipulationDonnees/main/dragons.csv\")\n```\n:::\n\n\n<br>\n\nVoici les **objectifs** de ce défi :\n\n-   mettre en forme les données (format tidy)\n\n-   créer un boxplot pour chaque espèce montrant l'effet des épices sur la taille des flammes\n\n<br>\n\nMalheureusement, vous apprenez que votre assistant a été peu scrupuleux lors de la collecte des données, et il vous faut **corriger les erreurs suivantes** :\n\n1.  La quatrième épice n'était pas du paprika, mais du curcuma\\\n2.  Lors des mesures avec le tabasco, l'appareil était mal calibré, mais seulement pour les Magyar à pointes : la taille des flammes a été sur-estimée de 30 cm\\\n3.  Les tailles sont données en centimètres, alors qu'elles devraient être en mètres.\n\n<br>\n\n**A votre tour de jouer!**\n\n<br>\n\nSi vous êtes coincé, vous pouvez cliquer ci-dessous pour afficher **quelques astuces** :\n\n\n::: {.cell code_folding='true'}\n\n```{.r .cell-code}\n# 1. Pour renommer la colonne \"paprika\", utilisez la fonction rename()\n\n# 2. Il existe plusieurs facons de corriger des valeurs :\n\nvaleurs_corrigees <- dragons$tabasco[dragons$espece == \"magyar_a_pointe\"] - 30\ndragons$tabasco[dragons$espece == \"magyar_a_pointe\"] <- valeurs_corrigees\n\ndragons <- dragons %>% \n  mutate(tabasco = ifelse(espece == \"magyar_a_pointe\", tabasco - 30, tabasco))\n\ndragons <- dragons %>% \n  mutate(tabasco = case_when(espece == \"magyar_a_pointe\" ~ tabasco - 30,\n                             TRUE ~ tabasco))\n\n# 3. La fonction mutate() vous permettra de convertir les centimètres en mètres\n```\n:::\n\n\n<br>\n\n**Cliquez ci-dessous pour voir la solution**\n\n\n::: {.cell code_folding='true'}\n\n```{.r .cell-code}\n# Importer les donnees\n\ndragons <- read_csv(\"https://raw.githubusercontent.com/codons-blog/C-02-ManipulationDonnees/main/dragons.csv\")\n\n# Nettoyer et corriger les donnees\n\ndragons_tidy <- dragons %>% \n  rename(curcuma = paprika) %>% \n  pivot_longer(cols = tabasco:curcuma,\n               names_to = \"epice\",\n               values_to = \"flamme_cm\") %>% \n  mutate(flamme_cm = case_when(espece == \"magyar_a_pointes\" & epice == \"tabasco\" ~ flamme_cm - 30,\n                               TRUE ~ flamme_cm)) %>% \n  mutate(flamme_m = flamme_cm / 100)\n\nmagyar_a_pointes <- dragons_tidy %>% filter(espece == \"magyar_a_pointes\")\nsuedois_a_museau_court <- dragons_tidy %>% filter(espece == \"suedois_a_museau_court\")\nvert_gallois <- dragons_tidy %>% filter(espece == \"vert_gallois\")\n\n# Boxplots\n\npar(mfrow = c(1, 3))\n\nboxplot(flamme_m ~ epice,\n        data = magyar_a_pointes,\n        xlab = \"Epice\",\n        ylab = \"Longueur flamme (m)\",\n        main = \"Magyar à pointes\")\n\nboxplot(flamme_m ~ epice,\n        data = suedois_a_museau_court,\n        xlab = \"Epice\",\n        ylab = \"Longueur flamme (m)\",\n        main = \"Suédois à museau court\")\n\nboxplot(flamme_m ~ epice,\n        data = vert_gallois,\n        xlab = \"Epice\",\n        ylab = \"Longueur flamme (m)\",\n        main = \"Vert gallois\")\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}