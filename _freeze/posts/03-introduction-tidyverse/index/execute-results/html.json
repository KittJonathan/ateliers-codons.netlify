{
  "hash": "ac113b2d4092ef18b72c154619e4b1ed",
  "result": {
    "markdown": "---\ntitle: \"Introduction au Tidyverse\"\nsubtitle: \"Utiliser le Tidyverse pour manipuler des données\"\nauthor:\n  - Sandra Angers-Blondin\n  - Jonathan Kitt (adaptation)\ndate: \"2022-10-24\"\ndraft: false\ncategories: [R, RStudio, Tidyverse]\nformat: \n  html: \n    toc: true\n    toc-depth: 2\n    toc-title: \"Sommaire\"\n---\n\n\n\n\n*Ce tutoriel est adapté de [Basic data manipulation](https://ourcodingclub.github.io/tutorials/data-manip-intro/index.html) et [Efficient data manipulation](https://ourcodingclub.github.io/tutorials/data-manip-efficient/) du site [Our Coding Club](https://ourcodingclub.github.io/).*\n\n<br>\n\n# Introduction\n\n## Qu'est-ce que le Tidyverse ?\n\nLe [Tidyverse](https://www.tidyverse.org/) est un ensemble de packages proposant de multiples fonctions utiles à l'ensemble des étapes d'une analyse :\n\n|                                               |                                       |\n|:--------------------------------------|:--------------------------------|\n| [readr](https://readr.tidyverse.org/)         | importer et exporter les données      |\n| [tibble](https://tibble.tidyverse.org/)       | format de tableau propre au tidyverse |\n| [dplyr](https://dplyr.tidyverse.org/)         | manipuler les données                 |\n| [tidyr](https://tidyr.tidyverse.org/)         | transformer des tableaux              |\n| [stringr](https://stringr.tidyverse.org/)     | manipuler des chaînes de caractères   |\n| [forcats](https://forcats.tidyverse.org/)     | manipuler des variables catégorielles |\n| [ggplot2](https://ggplot2.tidyverse.org/)     | représenter les données               |\n| [purrr](https://purrr.tidyverse.org/)         | programmation fonctionnelle           |\n| [lubridate](https://lubridate.tidyverse.org/) | manipuler des dates                   |\n\n<br>\n\n## Pré-requis\n\nSi vous n'avez pas suivi les autres tutoriels, vous pouvez [créer un projet RStudio](https://ateliers-codons.netlify.app/posts/02-premiers-pas-avec-r/#créer-un-projet) et [une arborescence](https://ateliers-codons.netlify.app/posts/02-premiers-pas-avec-r/#créer-une-arborescence).\n\nPour utiliser le Tidyverse, vous pouvez soit installer et charger séparément les packages dont vous aurez besoin, soit installer et charger directement la suite complète :\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Installer et charger les packages readr et dplyr\ninstall.packages(c(\"readr\", \"dplyr\"))\nlibrary(readr)\nlibrary(dplyr)\n\n# Installer et charger la suite Tidyverse\ninstall.packages(\"tidyverse\")\nlibrary(tidyverse)\n```\n:::\n\n\n::: {.callout-caution icon=\"true\"}\n## Les conflits\n\nLorsque vous exécutez la fonction `library(tidyverse)`, le message suivant s'affiche dans la console :\n\n![](img/tidyverse_intro_01.png)\n\nR vous indique :\n\n-   le nom et la version des packages individuels (*Attaching packages*)\\\n-   les fonctions portant des noms identiques existant dans d'autres packages (*Conflicts*)\n\nIl existe par exemple une fonction `filter()` dans le package `stats`. Si vous souhaitez utiliser cette dernière fonction plutôt que celle proposée dans le package `dplyr`, il vous foudra préciser le package en question : `stats::filter()`.\n:::\n\n<br>\n\n# Premiers pas dans le Tidyverse\n\nLes fonctions proposées dans les différents packages de la suite Tidyverse sont - en règle générale - nommées d'après les actions qu'elles accomplissent, ce qui rend leur mémorisation plus simple et leur utilisation plus intuitive.\n\n## Importer les données\n\nNous allons utiliser le même jeu de données que dans les tutoriels précédents (vous pouvez le télécharger [ici](https://raw.githubusercontent.com/codons-blog/ateliers-codons.netlify/main/raw/pingouins.csv) et le sauvegarder dans votre dossier `raw/`).\n\nPour importer les données, nous utilisons la fonction `read_csv()`, à ne pas comprendre avec la fonction `read.csv()` utilisée précédemment.\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npingouins <- readr::read_csv(file = \"raw/pingouins.csv\")\n```\n:::\n\n\nVous pouvez voir dans la console des informations concernant vos données :\\\n- les *dimensions* du tableau\\\n- le *séparateur* de colonnes\\\n- les *types* et les *noms* des variables\n\n<br>\n\nTapez `pingouins` dans la console et appuyze sur `Entrée` : vos données s'affichent et vous pouvez voir qu'il s'agit d'un *tibble*, qui présente quelques particularités par rapport à un tableau \"classique\" :\n\n-   les dimensions du *tibble* sont précisées\\\n-   les *types* des variables sont indiquées sous les noms des colonnes\\\n-   seules les *dix premières lignes* sont affichées\\\n-   le nombre de colonnes affichées dépend de la largeur de l'écran\\\n-   les noms de colonnes sont raccourcis si nécessaire\\\n-   les données manquantes *NA* sont mises en évidence\n\nPour bien voir la différence entre un `tibble` et un `data.frame`, comparez les deux commandes suivantes :\n\n\n::: {.cell}\n\n```{.r .cell-code}\npingouins\nas.data.frame(pingouins)\n```\n:::\n\n\n<br>\n\n## Explorer les données\n\nPlusieurs fonctions incluses dans R permettent d'explorer rapidement des données pour s'assurer qu'elles ont été correctement importées :\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Afficher les premieres lignes\nhead(pingouins)\n\n# Afficher les dernieres lignes\ntail(pingouins)\n\n# Afficher la structure des donnees\nstr(pingouins)\n```\n:::\n\n\nLa fonction `glimpse()` (du package `readr`) retourne sensiblement les mêmes informations que la fonction `str()` :\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::glimpse(pingouins)\n```\n:::\n\n\n<br>\n\n## Créer une copie de travail\n\nLa première chose à faire avant de manipuler, modifier et transformer nos données est de créer une copie de travail : cela nous permettra, en cas d'erreur, de repartir des données d'origines.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npingouins_tmp <- pingouins\n```\n:::\n\n\n<br>\n\n## Renommer des colonnes\n\nCommençons par renommer des colonnes afin de respecter les conventions d'écriture :\n\n-   *snake_case* : caractères minuscules, mots séparés par des `_`\\\n-   *camelCase* : aucune séparation entre les mots, majuscule pour débuter un mot\n\nLa fonction `rename` s'utilise de la façon suivante : `rename(data, nouveau nom = ancien nom)`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::rename(pingouins_tmp, ile = Ile)\n```\n:::\n\n\nNous pourrions procéder de la même façon pour plusieurs colonnes à la fois :\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::rename(pingouins_tmp, espece = Espece, ile = Ile)\n```\n:::\n\n\n<br>\n\nLe package [`janitor`](https://cran.r-project.org/web/packages/janitor/vignettes/janitor.html) est dédié au nettoyage d'un tableau (noms de colonnes, suppression des doublons, ...). Utilisons la fonction `clean_names()` de ce package :\n\n\n::: {.cell}\n\n```{.r .cell-code}\njanitor::clean_names(pingouins_tmp)\n```\n:::\n\n\nAssignons ces noms de colonnes nettoyés à notre copie de travail :\n\n\n::: {.cell}\n\n```{.r .cell-code}\npingouins_tmp <- janitor::clean_names(pingouins_tmp)\n```\n:::\n\n\nAssurons-nous que les noms de colonnes ont bien été modifiés :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(pingouins_tmp)\n```\n:::\n\n\n<br>\n\n::: {.callout-tip icon=\"true\"}\n## Explorer les arguments d'une fonction\n\nPour afficher l'aide de la fonction `clean_names`, tapez `?clean_names` (ou `?janitor::clean_names`) dans la console. Vous trouverez dans l'aide toutes les informations concernant une fonction. Dans notre cas, nous pourrions utiliser différentes conventions d'écriture pour nos noms de colonnes : `clean_names(pingouins_tmp, case = \"lower_camel\")` par exemple.\n:::\n\n<br>\n\n## Sélectionner des colonnes\n\nLa fonction `select()` permet de sélectionner les colonnes d'un tableau. Nous allons sélectionner les colonnes *espece*, *ile*, *longueur_bec_mm*, *hauteur_bec_mm*, *longueur_aile_mm* et *masse_corporelle_g*. Nous pouvons procéder de plusieurs façons :\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Indiquer toutes les colonnes\ndplyr::select(pingouins_tmp, espece, ile, longueur_bec_mm, hauteur_bec_mm,\n              longueur_aile_mm, masse_corporelle_g)\n\n# Indiquer les suites de colonnes\ndplyr::select(pingouins_tmp, espece:ile, longueur_bec_mm:masse_corporelle_g)\n\n# Supprimer des colonnes\ndplyr::select(pingouins_tmp, espece:ile, longueur_bec_mm:masse_corporelle_g)\n```\n:::\n\n\nD'autres fonctions du package `dplyr` permettent de sélectionner des colonnes :\n\n-   `contains()` : sélectionner les noms de colonnes qui contiennent un motif\\\n-   `starts_width()` : sélectionner les noms de colonnes qui commencent par un motif\\\n-   `ends_width()` : sélectionner les noms de colonnes qui se terminent par un motif\n\nDans notre cas, nous pouvons sélectionner les colonnes *espece* et *ile*, puis les colonnes dont le nom se termine par *mm* ou par *g* :\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Utiliser la fonction ends_with()\ndplyr::select(pingouins_tmp, espece, ile, dplyr::ends_with(c(\"mm\", \"g\")))\n```\n:::\n\n\nAssignons cette sélection de colonnes à notre objet :\n\n\n::: {.cell}\n\n```{.r .cell-code}\npingouins_tmp <- dplyr::select(pingouins_tmp, espece, ile, dplyr::ends_with(c(\"mm\", \"g\")))\n```\n:::\n\n\n<br>\n\n::: {.callout-tip icon=\"true\"}\n## Renommer et ré-ordonner des colonnes avec `select()`\n\nNous pouvons utiliser la fonction `select()` pour renommer des colonnes :\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::select(pingouins_tmp, espece:longueur_aile_mm, masse = masse_corporelle_g)\n```\n:::\n\n\nMais aussi pour modifier l'ordre des colonnes :\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::select(pingouins_tmp, espece:ile, masse_corporelle_g, longueur_bec_mm:longueur_aile_mm)\n```\n:::\n\n\nEnfin, si nous n'avons que quelques colonnes à déplacer, la fonction `everything()` permet de sélectionner le reste du tableau !\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::select(pingouins_tmp, ile, dplyr::everything())\n```\n:::\n\n:::\n\n<br>\n\n## Filtrer des données\n\nLa fonction `filter()` permet de filtrer les données à l'aide d'opérateurs logiques :\n\n|        |                     |\n|--------|---------------------|\n| `==`   | strictement égal à  |\n| `<=`   | inférieur ou égal à |\n| `<`    | inférieur à         |\n| `>=`   | supérieur ou égal à |\n| `>`    | supérieur à         |\n| `!=`   | différent de        |\n| `%in%` | appartient à        |\n| `&`    | et                  |\n| `|`    | ou                  |\n| `!`    | négation            |\n\nVoici deux exemples :\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Individus vivant sur l'ile Biscoe pesant au moins 5 kgs\ndplyr::filter(pingouins_tmp, ile == \"Biscoe\", masse_corporelle_g >= 5000)\n\n# Individus vivant sur les iles Biscoe ou Torgersen\ndplyr::filter(pingouins_tmp, ile %in% c(\"Biscoe\", \"Torgersen\"))\n```\n:::\n\n\nLa fonction `between()` permet de garder les valeurs numériques entre deux bornes :\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Individus pesant entre 3 kgs et 3,5 kgs\ndplyr::filter(pingouins_tmp, dplyr::between(masse_corporelle_g, 3000, 3250))\n```\n:::\n\n\n<br>\n\nNotre jeu de données contient des données manquantes `NA`. Il existe plusieurs manières de supprimer ces données manquantes :\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Garder les lignes pour lesquelles la variable longueur_bec_mm ne contient pas de NA\ndplyr::filter(pingouins_tmp, !is.na(longueur_bec_mm))\n\n# Supprimer les lignes pour lesquelles la variable longueur_bec_mm contient au moins un NA\ntidyr::drop_na(pingouins_tmp, longueur_bec_mm)\n\n# Supprimer les lignes contenant des NAs, quelque soit la variable\ntidyr::drop_na(pingouins_tmp)\n```\n:::\n\n\n<br>\n\n## Trier des données\n\nLa fonction `arrange()` permet de trier des données. Par défaut, le tri s'effectue par ordre croissant. Pour trier des données par ordre décroissant, il faut ajouter la fonction `desc()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Trier les données par ordre croisant de longueur de bec\ndplyr::arrange(pingouins_tmp, longueur_bec_mm)\n\n# Trier les données par ordre décroissant de masse corporelle\ndplyr::arrange(pingouins_tmp, dplyr::desc(masse_corporelle_g))\n```\n:::\n\n\nIl est possible de trier sur plusieurs colonnes : nous pouvons trier les individus par ordre décroissant de hauteur de bec puis par ordre décroissant de longueur de bec. Cela peut être utile pour départager des individus \"ex-aequo\" pour une variable :\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::arrange(pingouins_tmp, dplyr::desc(hauteur_bec_mm), dplyr::desc(longueur_bec_mm))\n```\n:::\n\n\n## Créer ou modifier des colonnes\n\nLa fonction `mutate()` permet de créer une nouvelle colonne. Nous pouvons par exemple ajouter une colonne *ratio_bec* dans laquelle nous allons calculer le rapport entre la longueur du bec et sa hauteur :\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::mutate(pingouins_tmp, ratio_bec = longueur_bec_mm / hauteur_bec_mm)\n```\n:::\n\n\nNous pouvons également modifier le contenu d'une colonne, par exemple en ajoutant le suffixe *island* au contenu de la colonne *ile* :\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::mutate(pingouins_tmp, ile = paste0(ile, \" island\"))\n```\n:::\n\n\nLa fonction `transmute()` permet quant à elle de créer une nouvelle colonne tout en supprimant les colonnes pré-existantes :\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::transmute(pingouins_tmp, masse_kgs = masse_corporelle_g / 1000)\n```\n:::\n\n\n<br>\n\n## Effectuer des comptages\n\nLa fonction `count()` permet d'effectuer des comptages sur les variables.\n\nComptons le nombre d'individus par espèce :\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::count(pingouins_tmp, espece)\n```\n:::\n\n\nL'argument `sort = TRUE` permet d'afficher le résultat par ordre décroissant :\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::count(pingouins_tmp, espece, sort = TRUE)\n```\n:::\n\n\nNous pouvons également compter les individus par île et par espèce :\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::count(pingouins_tmp, ile, espece, sort = TRUE)\n```\n:::\n\n\n<br>\n\n## Agréger des lignes\n\nLa fonction `summarise()` permet d'agréger des lignes en effectuant une opération.\n\nCalculons la longueur moyenne du bec pour l'ensemble des individus, sans oublier l'argument `na.rm = TRUE` pour supprimer les données manquantes lors du calcul. Si nous avions assigné à l'objet `pingouins_tmp` les données après avoir retiré les lignes contenant des données manquantes, nous pourrions nous passer de cet argument. Dans le doute, mieux vaut ajouter cet argument :\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::summarise(pingouins_tmp,\n                 longueur_bec_mm_moy = mean(longueur_bec_mm, na.rm = TRUE))\n```\n:::\n\n\nCette fonction peut également s'utiliser sur plusieurs variables :\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::summarise(pingouins_tmp,\n                 longueur_bec_mm_moy = mean(longueur_bec_mm, na.rm = TRUE),\n                 hauteur_bec_mm_moy = mean(hauteur_bec_mm, na.rm = TRUE))\n```\n:::\n\n\n<br>\n\n## Regrouper les données\n\nLa fonction `group_by()`, utilisée en combinaison avec la fonction `summarise()`, permet de regrouper les données pour effectuer des calculs par groupe.\n\nCalculons la longueur moyenne du bec par espece :\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::summarise(group_by(pingouins_tmp, espece),\n                 longueur_bec_mm_moy = mean(longueur_bec_mm, na.rm = TRUE))\n```\n:::\n\n\nCette fonction permet de définir des sous-groupes. Calculons la longueur moyenne du bec par île et par espèce :\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::summarise(dplyr::group_by(pingouins_tmp, ile, espece),\n                 longueur_bec_mm_moy = mean(longueur_bec_mm, na.rm = TRUE))\n```\n:::\n\n\n<br>\n\n# \"Ceci n'est pas un pipe\"\n\nJusqu'à présent, nous avons utilisé les fonctions une par une, en créant si nécessaire des objets intermédiaires. Cette façon de procéder peut rapidement encombrer notre environnement.\n\nIl existe une façon d'enchaîner les fonctions les unes à la suite des autres, qui présente plusieurs avantages :\n\n-   rendre le code plus clair et lisible\\\n-   réduire le nombre d'objets intermédiaires nécessaires à l'analyse\\\n-   permettre d'utiliser l'auto-complétion (à l'aide de la touche `Tab`)\n\nL'enchaînement des fonctions s'effectue à l'aide de ce que l'on appelle un *pipe*, disponible dans le package [`magrittr`](https://magrittr.tidyverse.org/).\n\n![](img/pipe_logo.png){width=\"20%\"}\n\nUn pipe s'écrit `%>%` et se place à la fin d'une ligne : \n\n\n::: {.cell}\n\n```{.r .cell-code}\npingouins %>%\n  janitor::clean_names()\n```\n:::\n\n\n\n::: {.callout-tip icon=\"true\"}\n## Raccourci clavier : le pipe\n\nPour insérer un pipe, utilisez la combinaison *Ctrl + Shift + M*\n\n:::\n\n<br>\n\nNous pouvons ainsi enchaîner les fonctions sans avoir à créer des objets intermédiaires : \n\n\n::: {.cell}\n\n```{.r .cell-code}\npingouins %>%\n  janitor::clean_names() %>%\n  dplyr::drop_na()\n```\n:::\n\n\n<br>\n\n::: {.callout-important icon=\"false\" collapse=\"true\"}\n## Exercice 1 - énoncé\n\nReprenons depuis le début et utilisons le pipe pour enchaîner les fonctions. \nLes commentaires ci-dessous indiquent les étapes : \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Assigner les étapes suivantes dans un objet pingouins_tmp\n# Importer les donnees brutes\n# Nettoyer les noms de colonnes\n# Selectionner les colonnes espece, ile ainsi que les variables numeriques\n# Supprimer les lignes contenant des donnees manquantes\n# Ajouter une colonne ratio_bec contenant le rapport entre la longueur et la hauteur des becs\n```\n:::\n\n\n:::\n\n::: {.callout-important icon=\"false\" collapse=\"true\"}\n## Exercice 1 - solution\n\n\n::: {.cell}\n\n```{.r .cell-code}\npingouins_tmp <- readr::read_csv(\"raw/pingouins.csv\") %>%\n  janitor::clean_names() %>%\n  dplyr::select(espece, ile, ends_with(c(\"mm\", \"g\"))) %>%\n  tidyr::drop_na() %>%\n  dplyr::mutate(ratio_bec = longueur_bec_mm / hauteur_bec_mm)\n```\n:::\n\n\n:::\n\n<br>\n\n::: {.callout-note icon=\"true\"}\n## Le pipe \"natif\" `|>`\n\nLes versions les plus récentes de R (à partir de 4.1) proposent un pipe \"natif\", qui ne nécessite pas de faire appel au package `magrittr`. Ce pipe s'écrit sous la forme `|>`. \n\nPour utiliser le pipe `|>`, cliquez sur *Tools* > *Global Options*. Dans le menu *Code* et l'onglet *Editing*,cochez la case *Use native pipe operator*.\n\n![](img/tidyverse_intro_02.png){width=\"50%}\n\nLe raccourci clavier **Ctrl + Shift + M** insérera alors un pipe `|>`.\n\n:::\n\n<br>\n\n# Manipuler des chaînes de caractères avec `stringr`\n\nLe package `stringr` est dédié à la manipulation de chaînes de caractères. Nous aimerions séparer la colonne *espece* en deux colonnes : \n\n- une colonne contenant le nom de l'espèce (*Adelie* par exemple)  \n- une colonne contenant le nom latin de l'espèce (*Pygoscelis adeliae*)\n\nLa fonction `str_detect()` permet de rechercher un motif dans une chaîne de caractères : \n\n\n::: {.cell}\n\n```{.r .cell-code}\nstringr::str_detect(string = pingouins_tmp$espece, pattern = \"Adelie\")\n```\n:::\n\n\nUtilisons la fonction `word()` pour extraire les troisèmes et quatrièmes mots de la variable espèce. Cette fonction s'utilise de la manière suivante : `str_word(chaine, debut, fin)`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npingouins_tmp <- pingouins_tmp %>%\n  dplyr::mutate(nom_latin = stringr::word(string = espece,\n                                          start = 3, end = 4))\n```\n:::\n\n\nNotre nouvelle variable *nom_latin* a bien été créée, mais elle contient des parenthèses. Pour les supprimer, nous utilisons la fonction `str_remove_all()` en combinaison avec une expression régulière (regex) : les parenthèses à supprimer sont placées entre crochets, eux-mêmes placés entre des guillemets.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npingouins_tmp <- pingouins_tmp %>%\n  dplyr::mutate(nom_latin = stringr::str_remove_all(string = nom_latin,\n                                                    pattern = \"[()]\"))\n```\n:::\n\n\nIl ne nous reste plus qu'à modifier la variable *espece* afin de ne conserver que le premier mot, puis de modifier l'ordre des colonnes :\n\n\n::: {.cell}\n\n```{.r .cell-code}\npingouins_tmp <- pingouins_tmp %>%\n  dplyr::mutate(espece = stringr::word(string = espece,\n                                       start = 1, end = 1)) %>%\n  dplyr::select(espece, nom_latin, dplyr::everything())\n```\n:::\n\n\n<br>\n\n::: {.callout-tip icon=\"true\"}\n## Les expressions régulières\n\nPour en savoir plus sur les expressions régulières, vous pouvez lire [cet article](https://thinkr.fr/r-les-expressions-regulieres/).\nIl existe souvent plusieurs façons d'arriver au même résultat. Pour le nom latin, nous aurions pu extraire la chaîne de caractères située entre les parenthèses : \n\n\n::: {.cell}\n\n```{.r .cell-code}\nstringr::str_extract(pingouins$Espece, \"(?<=\\\\().+?(?=\\\\))\")\n```\n:::\n\n\nPour extraire le nom de l'espèce, nous pouvons utiliser une expression régulière pour extraire les caractères précédent le premier espace vide : \n\n\n::: {.cell}\n\n```{.r .cell-code}\nstringr::str_extract(pingouins$Espece, \"\\\\w+\")\n```\n:::\n\n\n:::\n\n<br>\n\n# Joindre des tableaux\n\nLe package `dplyr` propose plusieurs fonctions pour joindre deux tableaux. Les lignes des deux tableaux seront associées en fonction de *clés*, c'est-à-dire des colonnes communes.\n\nLe schéma ci-dessous (tiré du livre [R for Data Science](https://r4ds.had.co.nz/relational-data.html)) représente les différentes fonctions `..._join()` : \n\n![](img/join-venn.png){width=\"50%\"}\n\n<br>\n\nPour bien comprendre ces différentes fonctions, nous allons créer deux sous-ensembles de données : \n\n- `d1` : lignes 1 à 3 du tableau, variable *longueur_bec_mm*  \n- `d2` : lignes 2 à 4 du tableau, variable *hauteur_bec_mm*\n\nNous commençons par ajouter une colonne contenant les numéros de ligne, à l'aide de la fonction `rowid_to_column()` du package `tibble`. Par défaut, cette fonction la colonne d'index au début du tableau, et l'argument `var = ` permet de choisir le nom de cette colonne. La fonction `slice()` permet de créer un sous-ensemble de lignes à l'aide de leurs positions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd1 <- pingouins_tmp %>%\n  tibble::rowid_to_column(var = \"ind_num\") %>%\n  dplyr::select(ind_num, longueur_bec_mm) %>%\n  dplyr::slice(1:3)\n\nd2 <- pingouins_tmp %>%\n  tibble::rowid_to_column(var = \"ind_num\") %>%\n  dplyr::select(ind_num, hauteur_bec_mm) %>%\n  dplyr::slice(2:4)\n```\n:::\n\n\n|                      |                                      | \n| -------------------- | ------------------------------------ |\n| `inner_join(d1, d2)` | ![](img/inner_join.png){width=\"50%\"} |\n| `full_join(d1, d2)`  | ![](img/full_join.png){width=\"50%\"}  |\n| `left_join(d1, d2)`  | ![](img/left_join.png){width=\"50%\"}  |\n| `right_join(d1, d2)` | ![](img/right_join.png){width=\"50%\"} |\n| `anti_join(d1, d2)`  | ![](img/anti_join_1.png){width=\"50%\"}|\n| `anti_join(d2, d1)`  | ![](img/anti_join_2.png){width=\"50%\"}|\n\n\nLe fichier `traitements.csv` contient des informations sur des **traitements appliqués aux plantes** : températe (T), fertilisation (F), température + fertilisation (TF), ou contrôle (C).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Importer le jeu de données (attention : utilisation de read_csv2)\n\ntraitements <- read_csv2(\"https://raw.githubusercontent.com/codons-blog/C-02-ManipulationDonnees/main/traitements.csv\")\n```\n:::\n\n\n<br>\n\nNous allons utiliser la fonction `left_join()` pour garder toutes les données présentes dans `croissance` et y associer les données présentes dans `traitements` :\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Joindre deux jeux de données\n\nexpe <- croissance %>% \n  left_join(traitements,\n            by = c(\"zone\" = \"Zone\",\n                   \"indiv\" = \"Indiv\"))\n```\n:::\n\n\n<br>\n\nSi les noms des deux premières colonnes avaient été strictement identiques dans les deux tableaux, nous aurions pu nous passer de l'argument `by()`.\n\n<br>\n\n# Mettre en forme des données à l'aide de `tidyr` {#tidyr}\n\nLes données que nous avons manipulées jusqu'à présent ne sont **pas dans un format idéal** (rappelez-vous la longueur du code pour calculer la croissance totale pour chaque individu).\n\nLes valeurs mesurées sont réparties dans différentes colonnes, une par année.\n\nNous pourrions mettre en forme ces donnes afin d'avoir une colonne \"annee\" et une colonne \"croissance\".\n\nC'est ce qu'on appelle des **tidy data**, concept qui repose sur trois critères :\n\n**1. Chaque variable est située dans sa propre colonne**\\\n**2. Chaque observation est située sur sa propre ligne**\\\n**3. Chaque valeur est située dans sa propre cellule**\n\n# `{r, layout=\"l-body\"} # knitr::include_graphics(\"img/tidy-1.png\") #`\n\n# Figure tirée de [R for Data Science](https://r4ds.had.co.nz/tidy-data.html)\n\n<br>\n\nConsidérons les deux premières lignes de notre tableau `croissance`, voici à quoi ressemblerait un format **tidy** :\n\n# `{r, layout=\"l-body-outset\"} # knitr::include_graphics(\"img/tidy_data.png\") #`\n\n<br>\n\nCe format **facilite les analyses** en permettant des comparaisons entre groupes, traitements, espèces, années, ...\n\nLe package `tidyr` permet de jongler entre ces deux formats grâce aux fonctions `pivot_...()`.\n\n# `{r, layout=\"l-body\"} # knitr::include_graphics(\"img/giphy.gif\") #`\n\n<br>\n\n## Format long avec `pivot_longer()`\n\nLa fonction `pivot_longer()` permet de passer d'un format large à un format long. La syntaxe est un peu plus complexe que les fonctions que nous avons vues jusqu'à présent, car il nous préciser quelles colonnes vont être regroupées :\n\n# `{r, layout=\"l-body-outset\"} # knitr::include_graphics(\"img/pivot_longer.png\") #`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Format large -> format long\n\ncroissance_long <- croissance %>% \n  pivot_longer(cols = `2007`:`2012`,\n               names_to = \"annee\",\n               values_to = \"croissance\")\n```\n:::\n\n\n<br>\n\n## Format large avec `pivot_wider()`\n\nCette fonction permet d'effectuer l'opération inverse :\n\n# `{r, layout=\"l-body-outset\"} # knitr::include_graphics(\"img/pivot_wider.png\") #`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Format long -> format large\n\ncroissance_large <- croissance_long %>% \n  pivot_wider(id_cols = zone:indiv,\n              names_from = annee,\n              values_from = croissance)\n```\n:::\n\n\n<br>\n\nDans les arguments `names_from` et `values_from` nous n'utilisons pas de guillemets car ces colonnes existent, contraitement aux arguments `names_to` et `values_to` de la fonction `pivot_longer()` qui permettent de créer des colonnes inexistantes.\n\n<br>\n\n## Résumé\n\nNous avons vu les principales fonctions des packages `dplyr` et `tidyr` une par une. Nous allons maintenant **enchaîner les différentes opérations** depuis le début à l'aide d'un `pipe` et **visualiser l'effet des différents traitements** sur la croissance des tiges d'*Empetrum* :\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Importer les deux fichiers\n\ncroissance <- read_csv(\"https://raw.githubusercontent.com/codons-blog/C-02-ManipulationDonnees/main/croissance.csv\")\ntraitements <- read_csv2(\"https://raw.githubusercontent.com/codons-blog/C-02-ManipulationDonnees/main/traitements.csv\")\n\n# Mettre en forme et joindre les deux fichiers\n\nexpe <- croissance %>% \n  pivot_longer(cols = `2007`:`2012`,\n               names_to = \"annee\",\n               values_to = \"croissance\") %>% \n  left_join(traitements) %>% \n  rename(zone = Zone,\n         indiv = Indiv,\n         traitement = Traitement) %>% \n  mutate(zone = as.factor(zone),\n         indiv = as.factor(indiv),\n         annee = as.numeric(annee),\n         traitement = as.factor(traitement))\n\n# Boxplot de l'effet des traitements sur la croissance\n\nboxplot(croissance ~ traitement, \n        data = expe,\n        main = \"Effet de la température (T) et de la fertilisation (F) sur la croissance d'Empetrum\",\n        xlab = \"Traitement\",\n        ylab = \"Croissance des tiges (cm)\")\n```\n:::\n\n\n<br>\n\n# `{r, layout=\"l-body-outset\"} # knitr::include_graphics(\"img/boxplot.png\") #`\n\n<br>\n\n## Bilan du tutoriel :\n\n1.  Vous savez utiliser les fonctions de `dplyr` pour manipuler vos données\\\n2.  Vous savez mettre en forme des données qui respectent les critères des tidy data avec `tidyr`\n\n<br>\n\n# Défi {#defi}\n\nPour ce défi, nous allons essayer de répondre à la question suivante : **quelle est l'effet de différentes épices sur la taille des flammes de trois espèces de dragons ?**\n\n<br>\n\nCommençons par importer les données :\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndragons <- read.csv(\"https://raw.githubusercontent.com/codons-blog/C-02-ManipulationDonnees/main/dragons.csv\")\n```\n:::\n\n\n<br>\n\nVoici les **objectifs** de ce défi :\n\n-   mettre en forme les données (format tidy)\n\n-   créer un boxplot pour chaque espèce montrant l'effet des épices sur la taille des flammes\n\n<br>\n\nMalheureusement, vous apprenez que votre assistant a été peu scrupuleux lors de la collecte des données, et il vous faut **corriger les erreurs suivantes** :\n\n1.  La quatrième épice n'était pas du paprika, mais du curcuma\\\n2.  Lors des mesures avec le tabasco, l'appareil était mal calibré, mais seulement pour les Magyar à pointes : la taille des flammes a été sur-estimée de 30 cm\\\n3.  Les tailles sont données en centimètres, alors qu'elles devraient être en mètres.\n\n<br>\n\n**A votre tour de jouer!**\n\n<br>\n\nSi vous êtes coincé, vous pouvez cliquer ci-dessous pour afficher **quelques astuces** :\n\n\n::: {.cell code_folding='true'}\n\n```{.r .cell-code}\n# 1. Pour renommer la colonne \"paprika\", utilisez la fonction rename()\n\n# 2. Il existe plusieurs facons de corriger des valeurs :\n\nvaleurs_corrigees <- dragons$tabasco[dragons$espece == \"magyar_a_pointe\"] - 30\ndragons$tabasco[dragons$espece == \"magyar_a_pointe\"] <- valeurs_corrigees\n\ndragons <- dragons %>% \n  mutate(tabasco = ifelse(espece == \"magyar_a_pointe\", tabasco - 30, tabasco))\n\ndragons <- dragons %>% \n  mutate(tabasco = case_when(espece == \"magyar_a_pointe\" ~ tabasco - 30,\n                             TRUE ~ tabasco))\n\n# 3. La fonction mutate() vous permettra de convertir les centimètres en mètres\n```\n:::\n\n\n<br>\n\n**Cliquez ci-dessous pour voir la solution**\n\n\n::: {.cell code_folding='true'}\n\n```{.r .cell-code}\n# Importer les donnees\n\ndragons <- read_csv(\"https://raw.githubusercontent.com/codons-blog/C-02-ManipulationDonnees/main/dragons.csv\")\n\n# Nettoyer et corriger les donnees\n\ndragons_tidy <- dragons %>% \n  rename(curcuma = paprika) %>% \n  pivot_longer(cols = tabasco:curcuma,\n               names_to = \"epice\",\n               values_to = \"flamme_cm\") %>% \n  mutate(flamme_cm = case_when(espece == \"magyar_a_pointes\" & epice == \"tabasco\" ~ flamme_cm - 30,\n                               TRUE ~ flamme_cm)) %>% \n  mutate(flamme_m = flamme_cm / 100)\n\nmagyar_a_pointes <- dragons_tidy %>% filter(espece == \"magyar_a_pointes\")\nsuedois_a_museau_court <- dragons_tidy %>% filter(espece == \"suedois_a_museau_court\")\nvert_gallois <- dragons_tidy %>% filter(espece == \"vert_gallois\")\n\n# Boxplots\n\npar(mfrow = c(1, 3))\n\nboxplot(flamme_m ~ epice,\n        data = magyar_a_pointes,\n        xlab = \"Epice\",\n        ylab = \"Longueur flamme (m)\",\n        main = \"Magyar à pointes\")\n\nboxplot(flamme_m ~ epice,\n        data = suedois_a_museau_court,\n        xlab = \"Epice\",\n        ylab = \"Longueur flamme (m)\",\n        main = \"Suédois à museau court\")\n\nboxplot(flamme_m ~ epice,\n        data = vert_gallois,\n        xlab = \"Epice\",\n        ylab = \"Longueur flamme (m)\",\n        main = \"Vert gallois\")\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}